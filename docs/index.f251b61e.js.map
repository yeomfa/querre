{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,S,E,C,E,O,G,E,U,C,E,O,C,C,C,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,Q,S,C,C,C,E,E,E,O,C,W,I,E,A,G,E,G,E,E,O,C,U,I,E,A,G,E,GCEA,IAcA,EACA,EAfI,EAAU,CAAC,EAcf,EAbA,SAAkB,CAAK,EAErB,IAAK,IADD,EAAO,OAAO,IAAA,CAAK,GACd,EAAI,EAAG,EAAI,EAAK,MAAA,CAAQ,IAC/B,CAAO,CAAC,CAAI,CAAC,EAAE,CAAC,CAAG,CAAK,CAAC,CAAI,CAAC,EAAE,CAAC,AAErC,EASA,EARA,SAAiB,CAAE,EACjB,IAAI,EAAW,CAAO,CAAC,EAAG,CAC1B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,CACT,C,GCfA,AAAA,EAAA,SAAA,QAAA,CAA8C,KAAK,KAAA,CAAM,mMCAzD;;;;gB,E,I,E,C,EEAA,EAAiB,IAAA,IAAoB,AAAA,EAAA,SAAA,OAAA,CAA6C,SAAA,YAAA,GAAA,EAAU,QAA5F,EDEA,OAAM,EACJ,CAAC,CAAa,CAAG,SAAS,aAAA,CAAc,QAAS,AAEjD,CAAA,QAAS,CACP,IAAM,EAAS,CAAC;;;mBAGD,EAAE,WAAA,EAAA,EAAA,GAAS;;;;;;;;;IAS1B,CAAC,AAED,CAAA,IAAI,CAAC,CAAC,CAAa,CAAC,SAAA,CAAY,CAClC,CAEA,iBAAiB,CAAO,CAAE,CACxB,IAAI,CAAC,CAAC,CAAa,CAAC,gBAAA,CAAiB,SAAU,AAAA,IAC7C,EAAE,cAAF,GAEA,IAAM,EAAW,SAAS,aAAA,CAAc,cAClC,EAAM,EAAS,KAArB,AAEI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","sources":["<anon>","node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","node_modules/@parcel/runtime-js/lib/runtime-a215f1449b66e028.js","src/controller.js","src/views/formView.js","node_modules/@parcel/runtime-js/lib/runtime-20e05a7654e99d0f.js","src/views/qrView.js","node_modules/@parcel/runtime-js/lib/runtime-2012e9072873fe36.js","node_modules/@parcel/runtime-js/lib/runtime-a33d26b85c3d92b8.js","src/thirdparties/qrcode.js"],"sourcesContent":["function $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $parcel$global =\ntypeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof self !== 'undefined'\n  ? self\n  : typeof window !== 'undefined'\n  ? window\n  : typeof global !== 'undefined'\n  ? global\n  : {};\nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire90f1\"];\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire90f1\"] = parcelRequire;\n}\nparcelRequire.register(\"27Lyk\", function(module, exports) {\n\n$parcel$export(module.exports, \"register\", () => $18c11f3350a906ea$export$6503ec6e8aabbaf, (v) => $18c11f3350a906ea$export$6503ec6e8aabbaf = v);\n$parcel$export(module.exports, \"resolve\", () => $18c11f3350a906ea$export$f7ad0328861e2f03, (v) => $18c11f3350a906ea$export$f7ad0328861e2f03 = v);\nvar $18c11f3350a906ea$export$6503ec6e8aabbaf;\nvar $18c11f3350a906ea$export$f7ad0328861e2f03;\n\"use strict\";\nvar $18c11f3350a906ea$var$mapping = {};\nfunction $18c11f3350a906ea$var$register(pairs) {\n    var keys = Object.keys(pairs);\n    for(var i = 0; i < keys.length; i++)$18c11f3350a906ea$var$mapping[keys[i]] = pairs[keys[i]];\n}\nfunction $18c11f3350a906ea$var$resolve(id) {\n    var resolved = $18c11f3350a906ea$var$mapping[id];\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return resolved;\n}\n$18c11f3350a906ea$export$6503ec6e8aabbaf = $18c11f3350a906ea$var$register;\n$18c11f3350a906ea$export$f7ad0328861e2f03 = $18c11f3350a906ea$var$resolve;\n\n});\n\nvar $af28bf336c783d06$exports = {};\n\n(parcelRequire(\"27Lyk\")).register(JSON.parse('{\"392in\":\"index.f251b61e.js\",\"jAwCd\":\"yeom-icon.c59e79dd.png\",\"jUwq8\":\"download.9ea3826b.svg\",\"frheu\":\"share.99e75b50.svg\"}'));\n\n/****************\\\n* Challenge #1   *\n* Querre         *\n* By: @yeomfa    *\n\\****************/ var $637432a930fda980$exports = {};\n\n$637432a930fda980$exports = new URL((parcelRequire(\"27Lyk\")).resolve(\"jAwCd\"), import.meta.url).toString();\n\n\nclass $2d6f167c801d3721$var$FormView {\n    #parentElement = document.querySelector(\".root\");\n    render() {\n        const markup = `\n      <section class=\"container-input section-form\">\n        <div class=\"title\">\n          <img src=${(0, (/*@__PURE__*/$parcel$interopDefault($637432a930fda980$exports)))} alt=\"yeom icon\">\n          <span>Querre</span>\n        </div>\n\n        <form class=\"app form-url\">\n          <input class=\"input-url\" type=\"text\" name=\"url\" value=\"\" placeholder=\"Enter an url\"> \n          <button class=\"btn-submit\" type=\"submit\">QR code</button>\n        </form>\n      </section>\n    `;\n        this.#parentElement.innerHTML = markup;\n    }\n    addHandlerSubmit(handler) {\n        this.#parentElement.addEventListener(\"submit\", (e)=>{\n            e.preventDefault();\n            const inputUrl = document.querySelector(\".input-url\");\n            const url = inputUrl.value;\n            if (url.length <= 1) return;\n            handler(url);\n            inputUrl.value = \"\";\n        });\n    }\n}\nvar $2d6f167c801d3721$export$2e2bcd8739ae039 = new $2d6f167c801d3721$var$FormView();\n\n\n\nvar $7af7f59580a84b33$exports = {};\n\n$7af7f59580a84b33$exports = new URL((parcelRequire(\"27Lyk\")).resolve(\"jUwq8\"), import.meta.url).toString();\n\n\nvar $bfcc6e0f6bfdf03d$exports = {};\n\n$bfcc6e0f6bfdf03d$exports = new URL((parcelRequire(\"27Lyk\")).resolve(\"frheu\"), import.meta.url).toString();\n\n\nclass $9945e03bc0452317$var$QRView {\n    #parentElement = document.querySelector(\".root\");\n    render(uri) {\n        const markup = `\n      <section class=\"container-qr section-qr\">\n        <header class=\"header-container\">\n          <div class=\"querre-icon\">\n            <img src=${(0, (/*@__PURE__*/$parcel$interopDefault($637432a930fda980$exports)))} alt=\"yeom icon\">\n            <span>Querre</span>\n          </div>\n        </header>\n\n        <div class=\"qr\">\n          <div class=\"shape\">\n            <img id=\"qrcode\" src=${uri}>\n          </div>\n        </div>\n\n        <div class=\"options\">\n          <button class=\"btn btn-download\">\n            Download\n            <img class=\"btn-icon\" src=${(0, (/*@__PURE__*/$parcel$interopDefault($7af7f59580a84b33$exports)))} alt=\"download icon\">\n          </button> \n          <button class=\"btn btn-share\">\n            Share\n            <img class=\"btn-icon\" src=${(0, (/*@__PURE__*/$parcel$interopDefault($bfcc6e0f6bfdf03d$exports)))} alt=\"download icon\">\n          </button> \n        </div>\n      </section>\n    `;\n        this.#parentElement.innerHTML = markup;\n    }\n    addHandlerIcon(handler) {\n        this.#parentElement.addEventListener(\"click\", (e)=>{\n            const icon = e.target.closest(\".querre-icon\");\n            if (!icon) return;\n            handler();\n        });\n    }\n    getQRElement() {\n        const qrEl = document.getElementById(\"qrcode\");\n        return qrEl;\n    }\n}\nvar $9945e03bc0452317$export$2e2bcd8739ae039 = new $9945e03bc0452317$var$QRView();\n\n\n// QR Code Generator\n// Dan Jackson, 2020\n// --- Bit Buffer Writing ---\nclass $ea450d57d71c3369$var$BitBuffer {\n    constructor(bitCapacity){\n        this.bitCapacity = bitCapacity;\n        const byteLength = this.bitCapacity + 7 >> 3;\n        this.buffer = new Uint8Array(byteLength);\n        this.bitOffset = 0;\n    }\n    append(value, bitCount) {\n        for(let i = 0; i < bitCount; i++){\n            const writeByte = this.buffer[this.bitOffset >> 3];\n            const writeBit = 7 - (this.bitOffset & 0x07);\n            const writeMask = 1 << writeBit;\n            const readMask = 1 << bitCount - 1 - i;\n            this.buffer[this.bitOffset >> 3] = writeByte & ~writeMask | (value & readMask ? writeMask : 0);\n            this.bitOffset++;\n        }\n    }\n    position() {\n        return this.bitOffset;\n    }\n    read(bitPosition) {\n        const value = this.buffer[bitPosition >> 3] & 1 << 7 - (bitPosition & 7) ? 1 : 0;\n        return value;\n    }\n}\n// --- Segment Modes ---\n// Segment Mode 0b0001 - Numeric\n// Maximal groups of 3/2/1 digits encoded to 10/7/4-bit binary\nclass $ea450d57d71c3369$var$SegmentNumeric {\n    static MODE = 0x01;\n    static CHARSET = \"0123456789\";\n    static canEncode(text) {\n        return [\n            ...text\n        ].every((c)=>$ea450d57d71c3369$var$SegmentNumeric.CHARSET.includes(c));\n    }\n    static payloadSize(text) {\n        const charCount = text.length;\n        return 10 * Math.floor(charCount / 3) + charCount % 3 * 4 - Math.floor(charCount % 3 / 2);\n    }\n    static countSize(version) {\n        return version < 10 ? 10 : version < 27 ? 12 : 14;\n    }\n    static totalSize(version, text) {\n        return $ea450d57d71c3369$var$Segment.MODE_BITS + $ea450d57d71c3369$var$SegmentNumeric.countSize(version) + $ea450d57d71c3369$var$SegmentNumeric.payloadSize(text);\n    }\n    static encode(bitBuffer, version, text) {\n        const data = [\n            ...text\n        ].map((c)=>c.charCodeAt(0) - 0x30);\n        bitBuffer.append($ea450d57d71c3369$var$SegmentNumeric.MODE, $ea450d57d71c3369$var$Segment.MODE_BITS);\n        bitBuffer.append(data.length, $ea450d57d71c3369$var$SegmentNumeric.countSize(version));\n        for(let i = 0; i < data.length;){\n            const remain = data.length - i > 3 ? 3 : data.length - i;\n            let value = data[i];\n            let bits = 4;\n            i++;\n            // Maximal groups of 3/2/1 digits encoded to 10/7/4-bit binary\n            if (i < data.length) {\n                value = value * 10 + data[i];\n                bits += 3;\n                i++;\n            }\n            if (i < data.length) {\n                value = value * 10 + data[i];\n                bits += 3;\n                i++;\n            }\n            bitBuffer.append(value, bits);\n        }\n    }\n}\n// Segment Mode 0b0010 - Alphanumeric\nclass $ea450d57d71c3369$var$SegmentAlphanumeric {\n    static MODE = 0x02;\n    static CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n    static canEncode(text) {\n        return [\n            ...text\n        ].every((c)=>$ea450d57d71c3369$var$SegmentAlphanumeric.CHARSET.includes(c));\n    }\n    static payloadSize(text) {\n        const charCount = text.length;\n        return 11 * Math.floor(charCount / 2) + 6 * (charCount % 2);\n    }\n    static countSize(version) {\n        return version < 10 ? 9 : version < 27 ? 11 : 13;\n    }\n    static totalSize(version, text) {\n        return $ea450d57d71c3369$var$Segment.MODE_BITS + $ea450d57d71c3369$var$SegmentAlphanumeric.countSize(version) + $ea450d57d71c3369$var$SegmentAlphanumeric.payloadSize(text);\n    }\n    static encode(bitBuffer, version, text) {\n        const data = [\n            ...text\n        ].map((c)=>$ea450d57d71c3369$var$SegmentAlphanumeric.CHARSET.indexOf(c));\n        bitBuffer.append($ea450d57d71c3369$var$SegmentAlphanumeric.MODE, $ea450d57d71c3369$var$Segment.MODE_BITS);\n        bitBuffer.append(data.length, $ea450d57d71c3369$var$SegmentAlphanumeric.countSize(version));\n        for(let i = 0; i < data.length;){\n            let value = data[i];\n            let bits = 6;\n            i++;\n            // Pairs combined(a * 45 + b) encoded as 11-bit; odd remainder encoded as 6-bit.\n            if (i < data.length) {\n                value = value * 45 + data[i];\n                bits += 5;\n                i++;\n            }\n            bitBuffer.append(value, bits);\n        }\n    }\n}\n// Segment Mode 0b0100 - 8-bit byte\nclass $ea450d57d71c3369$var$SegmentEightBit {\n    static MODE = 0x04;\n    static canEncode(text) {\n        return [\n            ...text\n        ].every((c)=>c.charCodeAt(0) >= 0x00 && c.charCodeAt(0) <= 0xff);\n    }\n    static payloadSize(text) {\n        const charCount = text.length;\n        return 8 * charCount;\n    }\n    static countSize(version) {\n        return version < 10 ? 8 : version < 27 ? 16 : 16; // 8-bit\n    }\n    static totalSize(version, text) {\n        return $ea450d57d71c3369$var$Segment.MODE_BITS + $ea450d57d71c3369$var$SegmentEightBit.countSize(version) + $ea450d57d71c3369$var$SegmentEightBit.payloadSize(text);\n    }\n    static encode(bitBuffer, version, text) {\n        const data = [\n            ...text\n        ].map((c)=>c.charCodeAt(0));\n        bitBuffer.append($ea450d57d71c3369$var$SegmentEightBit.MODE, $ea450d57d71c3369$var$Segment.MODE_BITS);\n        bitBuffer.append(data.length, $ea450d57d71c3369$var$SegmentEightBit.countSize(version));\n        for(let i = 0; i < data.length; i++)bitBuffer.append(data[i], 8);\n    }\n}\nclass $ea450d57d71c3369$var$Segment {\n    // In descending order of coding efficiency\n    static MODES = {\n        numeric: $ea450d57d71c3369$var$SegmentNumeric,\n        alphanumeric: $ea450d57d71c3369$var$SegmentAlphanumeric,\n        eightBit: $ea450d57d71c3369$var$SegmentEightBit\n    };\n    static MODE_BITS = 4;\n    static MODE_INDICATOR_TERMINATOR = 0x0;\n    // ECI Assignment Numbers\n    //static ECI_UTF8 = 26; // \"\\000026\" UTF8 - ISO/IEC 10646 UTF-8 encoding\n    constructor(text){\n        this.text = text;\n        for (let mode of Object.values($ea450d57d71c3369$var$Segment.MODES))if (mode.canEncode(this.text)) {\n            this.mode = mode;\n            return;\n        }\n        throw \"Cannot encode text\";\n    }\n}\n// --- Reed-Solomon Error-Correction Code ---\n// These error-correction functions are derived from https://www.nayuki.io/page/qr-code-generator-library Copyright (c) Project Nayuki. (MIT License)\nclass $ea450d57d71c3369$var$ReedSolomon {\n    // Product modulo GF(2^8/0x011D)\n    static Multiply(a, b) {\n        let value = 0; // 8-bit\n        for(let i = 7; i >= 0; i--){\n            value = (value << 1 ^ (value >> 7) * 0x011D) & 0xff;\n            value ^= (b >> i & 1) * a;\n        }\n        return value;\n    }\n    // Reed-Solomon ECC generator polynomial for given degree\n    static Divisor(degree) {\n        const result = new Uint8Array(degree); // <= QrCode.ECC_CODEWORDS_MAX\n        result.fill(0);\n        result[degree - 1] = 1;\n        let root = 1; // 8-bit\n        for(let i = 0; i < degree; i++){\n            for(let j = 0; j < degree; j++){\n                result[j] = $ea450d57d71c3369$var$ReedSolomon.Multiply(result[j], root);\n                if (j + 1 < degree) result[j] ^= result[j + 1];\n            }\n            root = $ea450d57d71c3369$var$ReedSolomon.Multiply(root, 0x02) & 0xff; // 8-bit\n        }\n        return result;\n    }\n    // Reed-Solomon ECC\n    static Remainder(data, dataOffset, dataLen, generator, degree, result, resultOffset) {\n        result.fill(0, resultOffset, resultOffset + degree);\n        for(let i = 0; i < dataLen; i++){\n            let factor = data[dataOffset + i] ^ result[resultOffset + 0];\n            // Move (degree-1) bytes from result[resultOffset+1] to result[resultOffset+0].\n            result.copyWithin(resultOffset, resultOffset + 1, resultOffset + 1 + degree - 1);\n            result[resultOffset + degree - 1] = 0;\n            for(let j = 0; j < degree; j++)result[resultOffset + j] ^= $ea450d57d71c3369$var$ReedSolomon.Multiply(generator[j], factor);\n        }\n    }\n}\n// --- 2D Matrix ---\nclass $ea450d57d71c3369$var$Matrix {\n    static MODULE_LIGHT = 0;\n    static MODULE_DARK = 1;\n    static FINDER_SIZE = 7;\n    static TIMING_OFFSET = 6;\n    static VERSION_SIZE = 3;\n    static ALIGNMENT_RADIUS = 2;\n    static QUIET_NONE = 0;\n    static QUIET_STANDARD = 4;\n    static calculateDimension(version) {\n        return 17 + 4 * version; // V1=21x21; V40=177x177\n    }\n    static calculateMask(maskPattern, j, i) {\n        switch(maskPattern){\n            case 0:\n                return (i + j & 1) == 0; // QRCODE_MASK_000\n            case 1:\n                return (i & 1) == 0; // QRCODE_MASK_001\n            case 2:\n                return j % 3 == 0; // QRCODE_MASK_010\n            case 3:\n                return (i + j) % 3 == 0; // QRCODE_MASK_011\n            case 4:\n                return ((i >> 1) + (j / 3 | 0) & 1) == 0; // QRCODE_MASK_100\n            case 5:\n                return (i * j & 1) + i * j % 3 == 0; // QRCODE_MASK_101\n            case 6:\n                return ((i * j & 1) + i * j % 3 & 1) == 0; // QRCODE_MASK_110\n            case 7:\n                return (i * j % 3 + (i + j & 1) & 1) == 0; // QRCODE_MASK_111\n            default:\n                return false;\n        }\n    }\n    // Returns coordinates to be used in all combinations (unless overlapping finder pattern) as x/y pairs for alignment, <0: end\n    static alignmentCoordinates(version) {\n        const count = version <= 1 ? 0 : Math.floor(version / 7) + 2;\n        const coords = Array(count);\n        const step = version == 32 ? 26 : Math.floor((version * 4 + count * 2 + 1) / (count * 2 - 2)) * 2; // step to previous\n        let location = version * 4 + 10; // lower alignment marker\n        for(let i = count - 1; i > 0; i--){\n            coords[i] = location;\n            location -= step;\n        }\n        if (count > 0) coords[0] = 6; // first alignment marker is at offset 6\n        return coords;\n    }\n    constructor(version){\n        this.version = version;\n        this.dimension = $ea450d57d71c3369$var$Matrix.calculateDimension(this.version);\n        const capacity = this.dimension * this.dimension;\n        this.buffer = new Array(capacity);\n        this.identity = new Array(capacity);\n        this.quiet = $ea450d57d71c3369$var$Matrix.QUIET_STANDARD;\n        this.invert = false;\n        this.text = null;\n    }\n    setModule(x, y, value, identity) {\n        if (x < 0 || y < 0 || x >= this.dimension || y >= this.dimension) return;\n        const index = y * this.dimension + x;\n        this.buffer[index] = value;\n        if (typeof identity !== \"undefined\") this.identity[index] = identity;\n    }\n    getModule(x, y) {\n        if (x < 0 || y < 0 || x >= this.dimension || y >= this.dimension) return null;\n        const index = y * this.dimension + x;\n        return this.buffer[index];\n    }\n    identifyModule(x, y) {\n        if (x < 0 || y < 0 || x >= this.dimension || y >= this.dimension) return undefined;\n        const index = y * this.dimension + x;\n        return this.identity[index];\n    }\n    // Draw finder and separator\n    drawFinder(ox, oy) {\n        for(let y = -Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2) - 1; y <= Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2) + 1; y++)for(let x = -Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2) - 1; x <= Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2) + 1; x++){\n            let value = (Math.abs(x) > Math.abs(y) ? Math.abs(x) : Math.abs(y)) & 1 ? $ea450d57d71c3369$var$Matrix.MODULE_DARK : $ea450d57d71c3369$var$Matrix.MODULE_LIGHT;\n            if (x == 0 && y == 0) value = $ea450d57d71c3369$var$Matrix.MODULE_DARK;\n            const id = x == 0 && y == 0 ? \"FI\" : \"Fi\";\n            this.setModule(ox + x, oy + y, value, id);\n        }\n    }\n    drawTiming() {\n        const id = \"Ti\";\n        for(let i = $ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1; i < this.dimension - $ea450d57d71c3369$var$Matrix.FINDER_SIZE - 1; i++){\n            let value = ~i & 1 ? $ea450d57d71c3369$var$Matrix.MODULE_DARK : $ea450d57d71c3369$var$Matrix.MODULE_LIGHT;\n            this.setModule(i, $ea450d57d71c3369$var$Matrix.TIMING_OFFSET, value, id);\n            this.setModule($ea450d57d71c3369$var$Matrix.TIMING_OFFSET, i, value, id);\n        }\n    }\n    drawAlignment(ox, oy) {\n        for(let y = -$ea450d57d71c3369$var$Matrix.ALIGNMENT_RADIUS; y <= $ea450d57d71c3369$var$Matrix.ALIGNMENT_RADIUS; y++)for(let x = -$ea450d57d71c3369$var$Matrix.ALIGNMENT_RADIUS; x <= $ea450d57d71c3369$var$Matrix.ALIGNMENT_RADIUS; x++){\n            let value = 1 - ((Math.abs(x) > Math.abs(y) ? Math.abs(x) : Math.abs(y)) & 1) ? $ea450d57d71c3369$var$Matrix.MODULE_DARK : $ea450d57d71c3369$var$Matrix.MODULE_LIGHT;\n            const id = x == 0 && y == 0 ? \"AL\" : \"Al\";\n            this.setModule(ox + x, oy + y, value, id);\n        }\n    }\n    // Populate the matrix with function patterns: finder, separators, timing, alignment, temporary version & format info\n    populateFunctionPatterns() {\n        this.drawFinder(Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2), Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2));\n        this.drawFinder(this.dimension - 1 - Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2), Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2));\n        this.drawFinder(Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2), this.dimension - 1 - Math.floor($ea450d57d71c3369$var$Matrix.FINDER_SIZE / 2));\n        this.drawTiming();\n        const alignmentCoords = $ea450d57d71c3369$var$Matrix.alignmentCoordinates(this.version);\n        for (let h of alignmentCoords)for (let v of alignmentCoords){\n            if (h <= $ea450d57d71c3369$var$Matrix.FINDER_SIZE && v <= $ea450d57d71c3369$var$Matrix.FINDER_SIZE) continue; // Obscured by top-left finder\n            if (h >= this.dimension - 1 - $ea450d57d71c3369$var$Matrix.FINDER_SIZE && v <= $ea450d57d71c3369$var$Matrix.FINDER_SIZE) continue; // Obscured by top-right finder\n            if (h <= $ea450d57d71c3369$var$Matrix.FINDER_SIZE && v >= this.dimension - 1 - $ea450d57d71c3369$var$Matrix.FINDER_SIZE) continue; // Obscured by bottom-left finder\n            this.drawAlignment(h, v);\n        }\n        // Draw placeholder format/version info (so that masking does not affect these parts)\n        this.drawFormatInfo(0);\n        this.drawVersionInfo(0);\n    }\n    // Set the data drawing cursor to the start position (lower-right corner)\n    cursorReset() {\n        this.cursorX = this.dimension - 1;\n        this.cursorY = this.dimension - 1;\n    }\n    // Advance the data drawing cursor to next position\n    cursorAdvance() {\n        while(this.cursorX >= 0){\n            // Right-hand side of 2-module column? (otherwise, left-hand side)\n            if (this.cursorX & 1 ^ (this.cursorX > $ea450d57d71c3369$var$Matrix.TIMING_OFFSET ? 1 : 0)) this.cursorX--;\n            else {\n                this.cursorX++;\n                // Upwards? (otherwise, downwards)\n                if ((this.cursorX - (this.cursorX > $ea450d57d71c3369$var$Matrix.TIMING_OFFSET ? 1 : 0)) / 2 & 1) {\n                    if (this.cursorY <= 0) this.cursorX -= 2;\n                    else this.cursorY--;\n                } else if (this.cursorY >= this.dimension - 1) this.cursorX -= 2;\n                else this.cursorY++;\n            }\n            if (!this.identifyModule(this.cursorX, this.cursorY)) return true;\n        }\n        return false;\n    }\n    cursorWrite(buffer, sourceBit, countBits) {\n        let index = sourceBit;\n        for(let countWritten = 0; countWritten < countBits; countWritten++){\n            let bit = buffer.read(index);\n            this.setModule(this.cursorX, this.cursorY, bit);\n            index++;\n            if (!this.cursorAdvance()) break;\n        }\n        return index - sourceBit;\n    }\n    // Draw 15-bit format information (2-bit error-correction level, 3-bit mask, 10-bit BCH error-correction; all masked)\n    drawFormatInfo(value) {\n        const id = \"Fo\";\n        for(let i = 0; i < 15; i++){\n            const v = value >> i & 1;\n            // 15-bits starting LSB clockwise from top-left finder avoiding timing strips\n            if (i < 6) this.setModule($ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, i, v, id);\n            else if (i == 6) this.setModule($ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, $ea450d57d71c3369$var$Matrix.FINDER_SIZE, v, id);\n            else if (i == 7) this.setModule($ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, $ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, v, id);\n            else if (i == 8) this.setModule($ea450d57d71c3369$var$Matrix.FINDER_SIZE, $ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, v, id);\n            else this.setModule(14 - i, $ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, v, id);\n            // lower 8-bits starting LSB right-to-left underneath top-right finder\n            if (i < 8) this.setModule(this.dimension - 1 - i, $ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, v, id);\n            else this.setModule($ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, this.dimension - $ea450d57d71c3369$var$Matrix.FINDER_SIZE - 8 + i, v, id);\n        }\n        // dark module\n        this.setModule($ea450d57d71c3369$var$Matrix.FINDER_SIZE + 1, this.dimension - 1 - $ea450d57d71c3369$var$Matrix.FINDER_SIZE, $ea450d57d71c3369$var$Matrix.MODULE_DARK, id);\n    }\n    // Draw 18-bit version information (6-bit version number, 12-bit error-correction (18,6) Golay code)\n    drawVersionInfo(value) {\n        const id = \"Ve\";\n        // No version information on V1-V6\n        if (value === null || this.version < 7) return;\n        for(let i = 0; i < 18; i++){\n            const v = value >> i & 1;\n            const col = Math.floor(i / $ea450d57d71c3369$var$Matrix.VERSION_SIZE);\n            const row = i % $ea450d57d71c3369$var$Matrix.VERSION_SIZE;\n            this.setModule(col, this.dimension - 1 - $ea450d57d71c3369$var$Matrix.FINDER_SIZE - $ea450d57d71c3369$var$Matrix.VERSION_SIZE + row, v, id);\n            this.setModule(this.dimension - 1 - $ea450d57d71c3369$var$Matrix.FINDER_SIZE - $ea450d57d71c3369$var$Matrix.VERSION_SIZE + row, col, v, id);\n        }\n    }\n    applyMaskPattern(maskPattern) {\n        for(let y = 0; y < this.dimension; y++)for(let x = 0; x < this.dimension; x++){\n            const part = this.identifyModule(x, y);\n            if (!part) {\n                const mask = $ea450d57d71c3369$var$Matrix.calculateMask(maskPattern, x, y);\n                if (mask) {\n                    const module = this.getModule(x, y);\n                    const value = 1 ^ module;\n                    this.setModule(x, y, value);\n                }\n            }\n        }\n    }\n    evaluatePenalty() {\n        // Note: Penalty calculated over entire code (although format information is not yet written)\n        const scoreN1 = 3;\n        //const scoreN2 = 3;\n        const scoreN3 = 40;\n        const scoreN4 = 10;\n        let totalPenalty = 0;\n        // Feature 1: Adjacent identical modules in row/column: (5 + i) count, penalty points: N1 + i\n        // Feature 3: 1:1:3:1:1 ratio patterns (either polarity) in row/column, penalty points: N3\n        for(let swapAxis = 0; swapAxis <= 1; swapAxis++){\n            let runs = Array(5);\n            let runsCount = 0;\n            for(let y = 0; y < this.dimension; y++){\n                let lastBit = -1;\n                let runLength = 0;\n                for(let x = 0; x < this.dimension; x++){\n                    let bit = this.getModule(swapAxis ? y : x, swapAxis ? x : y);\n                    // Run extended\n                    if (bit == lastBit) runLength++;\n                    // End of run\n                    if (bit != lastBit || x >= this.dimension - 1) {\n                        // If not start condition\n                        if (lastBit >= 0) {\n                            // Feature 1\n                            if (runLength >= 5) totalPenalty += scoreN1 + (runLength - 5);\n                            // Feature 3\n                            runsCount++;\n                            runs[runsCount % 5] = runLength;\n                            // Once we have a history of 5 lengths, check proportion\n                            if (runsCount >= 5) {\n                                // Proportion:             1 : 1 : 3 : 1 : 1\n                                // Modulo relative index: +3, +4,  0, +1, +2\n                                // Check for proportions\n                                let v = runs[(runsCount + 1) % 5];\n                                if (runs[runsCount % 5] == 3 * v && v == runs[(runsCount + 2) % 5] && v == runs[(runsCount + 3) % 5] && v == runs[(runsCount + 4) % 5]) totalPenalty += scoreN3;\n                            }\n                        }\n                        runLength = 1;\n                        lastBit = bit;\n                    }\n                }\n            }\n        }\n        // Feature 4: Dark module percentage: 50 +|- (5*k) to 50 +|- (5*(k+1)), penalty points: N4 * k\n        {\n            let darkCount = 0;\n            for(let y = 0; y < this.dimension; y++)for(let x = 0; x < this.dimension; x++){\n                let bit = this.getModule(x, y);\n                if (bit == $ea450d57d71c3369$var$Matrix.MODULE_DARK) darkCount++;\n            }\n            // Deviation from 50%\n            let percentage = (100 * darkCount + this.dimension * this.dimension / 2) / (this.dimension * this.dimension);\n            let deviation = Math.abs(percentage - 50);\n            let rating = Math.floor(deviation / 5);\n            let penalty = scoreN4 * rating;\n            totalPenalty += penalty;\n        }\n        return totalPenalty;\n    }\n}\nclass $ea450d57d71c3369$var$QrCode {\n    static VERSION_MIN = 1;\n    static VERSION_MAX = 40;\n    // In ascending order of robustness\n    static ErrorCorrectionLevel = {\n        L: 0x01,\n        M: 0x00,\n        Q: 0x03,\n        H: 0x02\n    };\n    static ECC_CODEWORDS_MAX = 30;\n    static PAD_CODEWORDS = 0xec11;\n    // Calculate the (square) dimension for a version. V1=21x21; V40=177x177.\n    static dimension(version) {\n        return 17 + 4 * version;\n    }\n    // Calculate the total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.\n    static totalDataModules(version) {\n        return (16 * version + 128) * version + 64 - (version < 2 ? 0 : (25 * (Math.floor(version / 7) + 2) - 10) * (Math.floor(version / 7) + 2) - 55) - (version < 7 ? 0 : 36);\n    }\n    // Calculate the total number of data bits available in the codewords (cooked: after ecc and remainder)\n    static dataCapacity(version, errorCorrectionLevel) {\n        const capacityCodewords = Math.floor($ea450d57d71c3369$var$QrCode.totalDataModules(version) / 8);\n        const eccTotalCodewords = $ea450d57d71c3369$var$QrCode.eccBlockCodewords(version, errorCorrectionLevel) * $ea450d57d71c3369$var$QrCode.eccBlockCount(version, errorCorrectionLevel);\n        const dataCapacityCodewords = capacityCodewords - eccTotalCodewords;\n        return dataCapacityCodewords * 8;\n    }\n    // Number of error correction blocks\n    static eccBlockCount(version, errorCorrectionLevel) {\n        const eccBlockCountLookup = [\n            [\n                0,\n                1,\n                1,\n                1,\n                2,\n                2,\n                4,\n                4,\n                4,\n                5,\n                5,\n                5,\n                8,\n                9,\n                9,\n                10,\n                10,\n                11,\n                13,\n                14,\n                16,\n                17,\n                17,\n                18,\n                20,\n                21,\n                23,\n                25,\n                26,\n                28,\n                29,\n                31,\n                33,\n                35,\n                37,\n                38,\n                40,\n                43,\n                45,\n                47,\n                49\n            ],\n            [\n                0,\n                1,\n                1,\n                1,\n                1,\n                1,\n                2,\n                2,\n                2,\n                2,\n                4,\n                4,\n                4,\n                4,\n                4,\n                6,\n                6,\n                6,\n                6,\n                7,\n                8,\n                8,\n                9,\n                9,\n                10,\n                12,\n                12,\n                12,\n                13,\n                14,\n                15,\n                16,\n                17,\n                18,\n                19,\n                19,\n                20,\n                21,\n                22,\n                24,\n                25\n            ],\n            [\n                0,\n                1,\n                1,\n                2,\n                4,\n                4,\n                4,\n                5,\n                6,\n                8,\n                8,\n                11,\n                11,\n                16,\n                16,\n                18,\n                16,\n                19,\n                21,\n                25,\n                25,\n                25,\n                34,\n                30,\n                32,\n                35,\n                37,\n                40,\n                42,\n                45,\n                48,\n                51,\n                54,\n                57,\n                60,\n                63,\n                66,\n                70,\n                74,\n                77,\n                81\n            ],\n            [\n                0,\n                1,\n                1,\n                2,\n                2,\n                4,\n                4,\n                6,\n                6,\n                8,\n                8,\n                8,\n                10,\n                12,\n                16,\n                12,\n                17,\n                16,\n                18,\n                21,\n                20,\n                23,\n                23,\n                25,\n                27,\n                29,\n                34,\n                34,\n                35,\n                38,\n                40,\n                43,\n                45,\n                48,\n                51,\n                53,\n                56,\n                59,\n                62,\n                65,\n                68\n            ]\n        ];\n        return eccBlockCountLookup[errorCorrectionLevel][version];\n    }\n    // Number of error correction codewords in each block\n    static eccBlockCodewords(version, errorCorrectionLevel) {\n        const eccBlockCodewordsLookup = [\n            [\n                0,\n                10,\n                16,\n                26,\n                18,\n                24,\n                16,\n                18,\n                22,\n                22,\n                26,\n                30,\n                22,\n                22,\n                24,\n                24,\n                28,\n                28,\n                26,\n                26,\n                26,\n                26,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28,\n                28\n            ],\n            [\n                0,\n                7,\n                10,\n                15,\n                20,\n                26,\n                18,\n                20,\n                24,\n                30,\n                18,\n                20,\n                24,\n                26,\n                30,\n                22,\n                24,\n                28,\n                30,\n                28,\n                28,\n                28,\n                28,\n                30,\n                30,\n                26,\n                28,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30\n            ],\n            [\n                0,\n                17,\n                28,\n                22,\n                16,\n                22,\n                28,\n                26,\n                26,\n                24,\n                28,\n                24,\n                28,\n                22,\n                24,\n                24,\n                30,\n                28,\n                28,\n                26,\n                28,\n                30,\n                24,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30\n            ],\n            [\n                0,\n                13,\n                22,\n                18,\n                26,\n                18,\n                24,\n                18,\n                22,\n                20,\n                24,\n                28,\n                26,\n                24,\n                20,\n                30,\n                24,\n                28,\n                28,\n                26,\n                30,\n                28,\n                30,\n                30,\n                30,\n                30,\n                28,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30,\n                30\n            ]\n        ];\n        return eccBlockCodewordsLookup[errorCorrectionLevel][version];\n    }\n    // Calculate 18-bit version information (6-bit version number, 12-bit error-correction (18,6) Golay code)\n    static calculateVersionInfo(version) {\n        if (version < 7) return null;\n        // Calculate 12-bit error-correction (18,6) Golay code\n        let golay = version;\n        for(let i = 0; i < 12; i++)golay = golay << 1 ^ (golay >>> 11) * 0x1f25;\n        const value = version << 12 | golay;\n        return value;\n    }\n    // Calculate 15-bit format information (2-bit error-correction level, 3-bit mask, 10-bit BCH error-correction; all masked)\n    static calculateFormatInfo(errorCorrectionLevel, maskPattern) {\n        // TODO: Reframe in terms of QRCODE_SIZE_ECL (2) and QRCODE_SIZE_MASK (3)\n        // LLMMM\n        const value = (errorCorrectionLevel & 0x03) << 3 | maskPattern & 0x07;\n        // Calculate 10-bit Bose-Chaudhuri-Hocquenghem (15,5) error-correction\n        let bch = value;\n        for(let i = 0; i < 10; i++)bch = bch << 1 ^ (bch >>> 9) * 0x0537;\n        // 0LLMMMEEEEEEEEEE\n        let format = value << 10 | bch & 0x03ff;\n        const formatMask = 0x5412; // 0b0101010000010010\n        format ^= formatMask;\n        return format;\n    }\n    // Total number of data bits used (may later require 0-padding to a byte boundary and padding bytes added)\n    static measureSegments(segments, version) {\n        let total = 0;\n        for (let segment of segments)total += segment.mode.totalSize(version, segment.text);\n        return total;\n    }\n    static doSegmentsFit(segments, version, errorCorrectionLevel) {\n        const sizeBits = $ea450d57d71c3369$var$QrCode.measureSegments(segments, version);\n        const dataCapacity = $ea450d57d71c3369$var$QrCode.dataCapacity(version, errorCorrectionLevel);\n        return sizeBits <= dataCapacity;\n    }\n    static findMinimumVersion(segments, errorCorrectionLevel, minVersion = $ea450d57d71c3369$var$QrCode.VERSION_MIN, maxVersion = $ea450d57d71c3369$var$QrCode.VERSION_MAX) {\n        for(let version = minVersion; version <= maxVersion; version++){\n            if ($ea450d57d71c3369$var$QrCode.doSegmentsFit(segments, version, errorCorrectionLevel)) return version;\n        }\n        throw \"Cannot fit data in any allowed versions\";\n    }\n    static tryToImproveErrorCorrectionLevel(segments, version, currentErrorCorrectionLevel) {\n        const ranking = Object.values($ea450d57d71c3369$var$QrCode.ErrorCorrectionLevel);\n        for(let i = 1; i < ranking.length; i++){\n            if (currentErrorCorrectionLevel == ranking[i - 1]) {\n                if ($ea450d57d71c3369$var$QrCode.doSegmentsFit(segments, version, ranking[i])) currentErrorCorrectionLevel = ranking[i];\n            }\n        }\n        return currentErrorCorrectionLevel;\n    }\n    // Write segments: header/count/payload\n    static writeData(scratchBuffer, version, segments) {\n        // Add segments (mode, count and data)\n        for (let segment of segments)segment.mode.encode(scratchBuffer, version, segment.text);\n    }\n    // Finish segments: given the available space, write terminator, rounding bits, and padding codewords\n    static writePadding(scratchBuffer, version, errorCorrectionLevel) {\n        // The total number of data bits available in the codewords (cooked: after ecc and remainder)\n        const dataCapacity = $ea450d57d71c3369$var$QrCode.dataCapacity(version, errorCorrectionLevel);\n        // Write only in capacity in any available space\n        let remaining;\n        // Add terminator 4-bit (0b0000)\n        remaining = Math.min(dataCapacity - scratchBuffer.position(), $ea450d57d71c3369$var$Segment.MODE_BITS);\n        scratchBuffer.append($ea450d57d71c3369$var$Segment.MODE_INDICATOR_TERMINATOR, remaining); // all zeros so won't be misaligned by partial write\n        // Remainder bits to round up to a whole byte\n        remaining = Math.min(dataCapacity - scratchBuffer.position(), 8 - (scratchBuffer.position() & 7) & 7);\n        scratchBuffer.append(0x00, remaining); // all zeros so won't be misaligned by partial write\n        // Remainder padding codewords \n        while((remaining = Math.min(dataCapacity - scratchBuffer.position(), 16)) > 0)scratchBuffer.append($ea450d57d71c3369$var$QrCode.PAD_CODEWORDS >> 16 - remaining, remaining); // align for partial write\n        // Check position matches expectation\n        console.assert(scratchBuffer.position() === dataCapacity, \"Unexpectedly failed to correctly fill the data buffer\");\n    }\n    // Calculate ECC data at the end of the codewords\n    // ...and fill the matrix\n    // TODO: Split this function into two (but depends on a lot of calculated state)\n    static calculateEccAndFillMatrix(scratchBuffer, version, errorCorrectionLevel, matrix) {\n        // Number of error correction blocks\n        const eccBlockCount = $ea450d57d71c3369$var$QrCode.eccBlockCount(version, errorCorrectionLevel);\n        // Number of error correction codewords in each block\n        const eccCodewords = $ea450d57d71c3369$var$QrCode.eccBlockCodewords(version, errorCorrectionLevel);\n        // The total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.\n        const totalCapacity = $ea450d57d71c3369$var$QrCode.totalDataModules(version);\n        // Codeword (byte) position in buffer for ECC data\n        const eccOffset = Math.floor((totalCapacity - 8 * eccCodewords * eccBlockCount) / 8);\n        console.assert(8 * eccOffset === scratchBuffer.bitOffset, `Expected current bit position ${scratchBuffer.bitOffset} to match ECC offset *8 ${8 * eccOffset}`);\n        // Calculate Reed-Solomon divisor\n        const eccDivisor = $ea450d57d71c3369$var$ReedSolomon.Divisor(eccCodewords);\n        const dataCapacityBytes = eccOffset;\n        const dataLenShort = Math.floor(dataCapacityBytes / eccBlockCount);\n        const countShortBlocks = eccBlockCount - (dataCapacityBytes - dataLenShort * eccBlockCount);\n        const dataLenLong = dataLenShort + (countShortBlocks >= eccBlockCount ? 0 : 1);\n        for(let block = 0; block < eccBlockCount; block++){\n            // Calculate offset and length (earlier consecutive blocks may be short by 1 codeword)\n            let dataOffset;\n            if (block < countShortBlocks) dataOffset = block * dataLenShort;\n            else dataOffset = block * dataLenShort + (block - countShortBlocks);\n            let dataLen = dataLenShort + (block < countShortBlocks ? 0 : 1);\n            // Calculate this block's ECC\n            let eccDest = eccOffset + block * eccCodewords;\n            $ea450d57d71c3369$var$ReedSolomon.Remainder(scratchBuffer.buffer, dataOffset, dataLen, eccDivisor, eccCodewords, scratchBuffer.buffer, eccDest);\n        }\n        // Fill the matrix with data\n        // Write the codewords interleaved between blocks\n        matrix.cursorReset();\n        let totalWritten = 0;\n        // Write data codewords interleaved across ecc blocks -- some early blocks may be short\n        for(let i = 0; i < dataLenLong; i++)for(let block = 0; block < eccBlockCount; block++){\n            // Calculate offset and length (earlier consecutive blocks may be short by 1 codeword)\n            // Skip codewords due to short block\n            if (i >= dataLenShort && block < countShortBlocks) continue;\n            const codeword = block * dataLenShort + (block > countShortBlocks ? block - countShortBlocks : 0) + i;\n            const sourceBit = codeword * 8;\n            const countBits = 8;\n            totalWritten += matrix.cursorWrite(scratchBuffer, sourceBit, countBits);\n        }\n        // Write ECC codewords interleaved across ecc blocks\n        for(let i = 0; i < eccCodewords; i++)for(let block = 0; block < eccBlockCount; block++){\n            const sourceBit = 8 * eccOffset + block * eccCodewords * 8 + i * 8;\n            const countBits = 8;\n            totalWritten += matrix.cursorWrite(scratchBuffer, sourceBit, countBits);\n        }\n        // Add any remainder 0 bits (could be 0/3/4/7)\n        const bit = $ea450d57d71c3369$var$Matrix.MODULE_LIGHT;\n        while(totalWritten < totalCapacity){\n            matrix.setModule(matrix.cursorX, matrix.cursorY, bit);\n            totalWritten++;\n            if (!matrix.cursorAdvance()) break;\n        }\n    }\n    //\n    static findOptimalMaskPattern(matrix) {\n        let lowestPenalty = -1;\n        let bestMaskPattern = null;\n        for(let maskPattern = 0; maskPattern <= 7; maskPattern++){\n            // XOR mask pattern\n            matrix.applyMaskPattern(maskPattern);\n            // Find penalty score for this mask pattern\n            const penalty = matrix.evaluatePenalty();\n            // XOR same mask removes it\n            matrix.applyMaskPattern(maskPattern);\n            // See if this is the best so far\n            if (lowestPenalty < 0 || penalty < lowestPenalty) {\n                lowestPenalty = penalty;\n                bestMaskPattern = maskPattern;\n            }\n        }\n        return bestMaskPattern;\n    }\n    constructor(){}\n    static generate(text, userOptions) {\n        // Generation options\n        const options = Object.assign({\n            errorCorrectionLevel: $ea450d57d71c3369$var$QrCode.ErrorCorrectionLevel.M,\n            minVersion: $ea450d57d71c3369$var$QrCode.VERSION_MIN,\n            maxVersion: $ea450d57d71c3369$var$QrCode.VERSION_MAX,\n            optimizeEcc: true,\n            maskPattern: null,\n            quiet: $ea450d57d71c3369$var$Matrix.QUIET_STANDARD,\n            invert: false\n        }, userOptions);\n        // Allow either a single text string or an array of text strings likely to encode as different modes\n        const textArray = Array.isArray(text) ? text : [\n            text\n        ];\n        // Create a segment for the text, each with its own best-fit encoding mode\n        const segments = textArray.map((text)=>new $ea450d57d71c3369$var$Segment(text));\n        // Fit the payload to a version (dimension)\n        let errorCorrectionLevel = options.errorCorrectionLevel;\n        const version = $ea450d57d71c3369$var$QrCode.findMinimumVersion(segments, errorCorrectionLevel, options.minVersion, options.maxVersion);\n        // Try to find a better error correction level for the given size\n        if (options.optimizeEcc) errorCorrectionLevel = $ea450d57d71c3369$var$QrCode.tryToImproveErrorCorrectionLevel(segments, version, errorCorrectionLevel);\n        // 'scratchBuffer' to contain the entire data bitstream for the QR Code\n        // (payload with headers, terminator, rounding bits, padding modules, ECC, remainder bits)\n        const totalCapacity = $ea450d57d71c3369$var$QrCode.totalDataModules(version); // The total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.\n        const scratchBuffer = new $ea450d57d71c3369$var$BitBuffer(totalCapacity);\n        // Write segments: header/count/payload\n        $ea450d57d71c3369$var$QrCode.writeData(scratchBuffer, version, segments);\n        // Finish segments: given the available space, write terminator, rounding bits, and padding codewords\n        $ea450d57d71c3369$var$QrCode.writePadding(scratchBuffer, version, errorCorrectionLevel);\n        // Create an empty matrix\n        const matrix = new $ea450d57d71c3369$var$Matrix(version);\n        matrix.text = text;\n        matrix.quiet = options.quiet;\n        matrix.invert = options.invert;\n        // Populate the matrix with function patterns: finder, separators, timing, alignment, temporary version & format info\n        matrix.populateFunctionPatterns();\n        // Calculate ECC and fill matrix\n        $ea450d57d71c3369$var$QrCode.calculateEccAndFillMatrix(scratchBuffer, version, errorCorrectionLevel, matrix);\n        // Calculate the optimal mask pattern\n        let maskPattern = options.maskPattern;\n        if (maskPattern === null) maskPattern = $ea450d57d71c3369$var$QrCode.findOptimalMaskPattern(matrix);\n        // Apply the chosen mask pattern\n        matrix.applyMaskPattern(maskPattern);\n        // Populate the matrix with version information\n        const versionInfo = $ea450d57d71c3369$var$QrCode.calculateVersionInfo(version);\n        matrix.drawVersionInfo(versionInfo);\n        // Fill-in format information\n        const formatInfo = $ea450d57d71c3369$var$QrCode.calculateFormatInfo(errorCorrectionLevel, maskPattern);\n        matrix.drawFormatInfo(formatInfo);\n        return matrix;\n    }\n    static render(mode, matrix, renderOptions) {\n        const renderers = {\n            \"debug\": $ea450d57d71c3369$var$renderDebug,\n            \"large\": $ea450d57d71c3369$var$renderTextLarge,\n            \"medium\": $ea450d57d71c3369$var$renderTextMedium,\n            \"compact\": $ea450d57d71c3369$var$renderTextCompact,\n            \"svg\": $ea450d57d71c3369$var$renderSvg,\n            \"svg-uri\": $ea450d57d71c3369$var$renderSvgUri,\n            \"bmp\": $ea450d57d71c3369$var$renderBmp,\n            \"bmp-uri\": $ea450d57d71c3369$var$renderBmpUri\n        };\n        if (!renderers[mode]) throw new Error(\"ERROR: Invalid render mode: \" + mode);\n        return renderers[mode](matrix, renderOptions);\n    }\n}\n// Generate a bitmap from an array of [R,G,B] or [R,G,B,A] pixels\nfunction $ea450d57d71c3369$var$BitmapGenerate(data, width, height, alpha = false) {\n    const bitsPerPixel = alpha ? 32 : 24;\n    const fileHeaderSize = 14;\n    const bmpHeaderSizeByVersion = {\n        BITMAPCOREHEADER: 12,\n        BITMAPINFOHEADER: 40,\n        BITMAPV2INFOHEADER: 52,\n        BITMAPV3INFOHEADER: 56,\n        BITMAPV4HEADER: 108,\n        BITMAPV5HEADER: 124\n    };\n    const version = alpha ? \"BITMAPV4HEADER\" : \"BITMAPCOREHEADER\"; // V3 provides alpha on Chrome, but V4 required for Firefox\n    if (!bmpHeaderSizeByVersion.hasOwnProperty(version)) throw `Unknown BMP header version: ${version}`;\n    const bmpHeaderSize = bmpHeaderSizeByVersion[version];\n    const stride = 4 * Math.floor((width * Math.floor((bitsPerPixel + 7) / 8) + 3) / 4); // Byte width of each line\n    const biSizeImage = stride * Math.abs(height); // Total number of bytes that will be written\n    const bfOffBits = fileHeaderSize + bmpHeaderSize; // + paletteSize\n    const bfSize = bfOffBits + biSizeImage;\n    const buffer = new ArrayBuffer(bfSize);\n    const view = new DataView(buffer);\n    // Write 14-byte BITMAPFILEHEADER\n    view.setUint8(0, \"B\".charCodeAt(0));\n    view.setUint8(1, \"M\".charCodeAt(0)); // @0 WORD bfType\n    view.setUint32(2, bfSize, true); // @2 DWORD bfSize\n    view.setUint16(6, 0, true); // @6 WORD bfReserved1\n    view.setUint16(8, 0, true); // @8 WORD bfReserved2\n    view.setUint32(10, bfOffBits, true); // @10 DWORD bfOffBits\n    if (bmpHeaderSize == bmpHeaderSizeByVersion.BITMAPCOREHEADER) {\n        view.setUint32(14, bmpHeaderSize, true); // @14 DWORD biSize\n        view.setUint16(18, width, true); // @18 WORD biWidth\n        view.setInt16(20, height, true); // @20 WORD biHeight\n        view.setUint16(22, 1, true); // @26 WORD biPlanes\n        view.setUint16(24, bitsPerPixel, true); // @28 WORD biBitCount\n    } else if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPINFOHEADER) {\n        view.setUint32(14, bmpHeaderSize, true); // @14 DWORD biSize\n        view.setUint32(18, width, true); // @18 DWORD biWidth\n        view.setInt32(22, height, true); // @22 DWORD biHeight\n        view.setUint16(26, 1, true); // @26 WORD biPlanes\n        view.setUint16(28, bitsPerPixel, true); // @28 WORD biBitCount\n        view.setUint32(30, alpha ? 3 : 0, true); // @30 DWORD biCompression (0=BI_RGB, 3=BI_BITFIELDS, 6=BI_ALPHABITFIELDS on Win-CE-5)\n        view.setUint32(34, biSizeImage, true); // @34 DWORD biSizeImage\n        view.setUint32(38, 2835, true); // @38 DWORD biXPelsPerMeter\n        view.setUint32(42, 2835, true); // @42 DWORD biYPelsPerMeter\n        view.setUint32(46, 0, true); // @46 DWORD biClrUsed\n        view.setUint32(50, 0, true); // @50 DWORD biClrImportant\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV2INFOHEADER) {\n        view.setUint32(54, alpha ? 0x00ff0000 : 0x00000000, true); // @54 DWORD bRedMask\n        view.setUint32(58, alpha ? 0x0000ff00 : 0x00000000, true); // @58 DWORD bGreenMask\n        view.setUint32(62, alpha ? 0x000000ff : 0x00000000, true); // @62 DWORD bBlueMask\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV3INFOHEADER) view.setUint32(66, alpha ? 0xff000000 : 0x00000000, true); // @66 DWORD bAlphaMask\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV4HEADER) {\n        const colorSpace = \"Win \"; // \"BGRs\";       // @ 70 DWORD bCSType\n        view.setUint8(70, colorSpace.charCodeAt(0));\n        view.setUint8(71, colorSpace.charCodeAt(1));\n        view.setUint8(72, colorSpace.charCodeAt(2));\n        view.setUint8(73, colorSpace.charCodeAt(3));\n        // @74 sizeof(CIEXYZTRIPLE)=36 (can be left empty for \"Win \")\n        view.setUint32(110, 0, true); // @110 DWORD bGammaRed\n        view.setUint32(114, 0, true); // @114 DWORD bGammaGreen\n        view.setUint32(118, 0, true); // @118 DWORD bGammaBlue\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV5HEADER) {\n        view.setUint32(122, 0x4, true); // @122 DWORD bIntent (0x1=LCS_GM_BUSINESS, 0x2=LCS_GM_GRAPHICS, 0x4=LCS_GM_IMAGES, 0x8=LCS_GM_ABS_COLORIMETRIC)\n        view.setUint32(126, 0, true); // @126 DWORD bProfileData\n        view.setUint32(130, 0, true); // @130 DWORD bProfileSize\n        view.setUint32(134, 0, true); // @134 DWORD bReserved\n    }\n    // If there was one, write the palette here (fileHeaderSize + bmpHeaderSize)\n    // Write pixels\n    for(let y = 0; y < height; y++){\n        let offset = bfOffBits + (height - 1 - y) * stride;\n        for(let x = 0; x < width; x++){\n            const value = data[y * width + x];\n            view.setUint8(offset + 0, value[2]); // B\n            view.setUint8(offset + 1, value[1]); // G\n            view.setUint8(offset + 2, value[0]); // R\n            if (alpha) {\n                view.setUint8(offset + 3, value[3]); // A\n                offset += 4;\n            } else offset += 3;\n        }\n    }\n    return buffer;\n}\nfunction $ea450d57d71c3369$var$renderDebug(matrix, options) {\n    options = Object.assign({\n        segments: [\n            \"  \",\n            \"\"\n        ],\n        sep: \"\\n\"\n    }, options);\n    const lines = [];\n    for(let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y++){\n        const parts = [];\n        for(let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x++){\n            let part = matrix.identifyModule(x, y);\n            const bit = matrix.getModule(x, y) ? !matrix.invert : matrix.invert;\n            const value = bit ? 1 : 0;\n            if (typeof part == \"undefined\" || part === null) part = options.segments[value];\n            parts.push(part);\n        }\n        lines.push(parts.join(\"\"));\n    }\n    return lines.join(options.sep);\n}\nfunction $ea450d57d71c3369$var$renderTextLarge(matrix, options) {\n    options = Object.assign({\n        segments: [\n            \"  \",\n            \"\"\n        ],\n        sep: \"\\n\"\n    }, options);\n    const lines = [];\n    for(let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y++){\n        const parts = [];\n        for(let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x++){\n            const bit = matrix.getModule(x, y) ? !matrix.invert : matrix.invert;\n            const value = bit ? 1 : 0;\n            // If an additional segment type is specified, use it to identify data modules differently\n            const chars = options.segments.length >= 3 && bit && !matrix.identifyModule(x, y) ? options.segments[2] : options.segments[value];\n            parts.push(chars);\n        }\n        lines.push(parts.join(\"\"));\n    }\n    return lines.join(options.sep);\n}\nfunction $ea450d57d71c3369$var$renderTextMedium(matrix, options) {\n    options = Object.assign({\n        segments: [\n            \" \",\n            \"\",\n            \"\",\n            \"\"\n        ],\n        sep: \"\\n\"\n    }, options);\n    const lines = [];\n    for(let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y += 2){\n        const parts = [];\n        for(let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x++){\n            const upper = matrix.getModule(x, y) ? !matrix.invert : matrix.invert;\n            const lower = (y + 1 < matrix.dimension ? matrix.getModule(x, y + 1) : 0) ? !matrix.invert : matrix.invert;\n            const value = (upper ? 0x01 : 0) | (lower ? 0x02 : 0);\n            // '', '', '' // '\\u{0020}' space, '\\u{2580}' upper half block, '\\u{2584}' lower half block, '\\u{2588}' block\n            const c = options.segments[value];\n            parts.push(c);\n        }\n        lines.push(parts.join(\"\"));\n    }\n    return lines.join(options.sep);\n}\nfunction $ea450d57d71c3369$var$renderTextCompact(matrix, options) {\n    options = Object.assign({\n        segments: [\n            \" \",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\",\n            \"\"\n        ],\n        sep: \"\\n\"\n    }, options);\n    const lines = [];\n    for(let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y += 2){\n        const parts = [];\n        for(let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x += 2){\n            let value = 0;\n            value |= (matrix.getModule(x, y) ? !matrix.invert : matrix.invert) ? 0x01 : 0x00;\n            value |= ((x + 1 < matrix.dimension ? matrix.getModule(x + 1, y) : 0) ? !matrix.invert : matrix.invert) ? 0x02 : 0x00;\n            value |= ((y + 1 < matrix.dimension ? matrix.getModule(x, y + 1) : 0) ? !matrix.invert : matrix.invert) ? 0x04 : 0x00;\n            value |= ((y + 1 < matrix.dimension && x + 1 < matrix.dimension ? matrix.getModule(x + 1, y + 1) : 0) ? !matrix.invert : matrix.invert) ? 0x08 : 0x00;\n            let c = options.segments[value];\n            parts.push(c);\n        }\n        lines.push(parts.join(\"\"));\n    }\n    return lines.join(options.sep);\n}\nfunction $ea450d57d71c3369$var$escape(text) {\n    return text.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\\\"/g, \"&quot;\").replace(/\\'/g, \"&apos;\");\n}\nfunction $ea450d57d71c3369$var$renderSvg(matrix, options) {\n    options = Object.assign({\n        moduleRound: null,\n        finderRound: null,\n        alignmentRound: null,\n        white: false,\n        moduleSize: 1\n    }, options);\n    const vbTopLeft = `${-matrix.quiet - options.moduleSize / 2}`;\n    const vbWidthHeight = `${2 * (matrix.quiet + options.moduleSize / 2) + matrix.dimension - 1}`;\n    const lines = [];\n    lines.push(`<?xml version=\"1.0\"?>`);\n    // viewport-fill=\\\"white\\\" \n    lines.push(`<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"currentColor\" viewBox=\"${vbTopLeft} ${vbTopLeft} ${vbWidthHeight} ${vbWidthHeight}\" shape-rendering=\"crispEdges\">`);\n    lines.push(`<title>${$ea450d57d71c3369$var$escape(matrix.text)}</title>`);\n    //lines.push(`<desc>${escape(matrix.text)}</desc>`);\n    lines.push(`<defs>`);\n    // module data bit (dark)\n    lines.push(`<rect id=\"b\" x=\"${-options.moduleSize / 2}\" y=\"${-options.moduleSize / 2}\" width=\"${options.moduleSize}\" height=\"${options.moduleSize}\" rx=\"${0.5 * (options.moduleRound || 0) * options.moduleSize}\" />`);\n    // module data bit (light). \n    if (options.white) lines.push(`<path id=\"w\" d=\"\" visibility=\"hidden\" />`);\n    // Use one item for the finder marker\n    if (options.finderRound != null) {\n        // Hide finder module, use finder part\n        lines.push(`<path id=\"f\" d=\"\" visibility=\"hidden\" />`);\n        if (options.white) lines.push(`<path id=\"fw\" d=\"\" visibility=\"hidden\" />`);\n        lines.push(`<g id=\"fc\"><rect x=\"-3\" y=\"-3\" width=\"6\" height=\"6\" rx=\"${3.0 * options.finderRound}\" stroke=\"currentColor\" stroke-width=\"1\" fill=\"none\" /><rect x=\"-1.5\" y=\"-1.5\" width=\"3\" height=\"3\" rx=\"${1.5 * options.finderRound}\" /></g>`);\n        lines.push(`<g id=\"fc\"><rect x=\"-3\" y=\"-3\" width=\"6\" height=\"6\" rx=\"${3.0 * options.finderRound}\" stroke=\"currentColor\" stroke-width=\"1\" fill=\"none\" /><rect x=\"-1.5\" y=\"-1.5\" width=\"3\" height=\"3\" rx=\"${1.5 * options.finderRound}\" /></g>`);\n    } else {\n        // Use normal module for finder module, hide finder part\n        lines.push(`<use id=\"f\" xlink:href=\"#b\" />`);\n        if (options.white) lines.push(`<use id=\"fw\" xlink:href=\"#w\" />`);\n        lines.push(`<path id=\"fc\" d=\"\" visibility=\"hidden\" />`);\n    }\n    // Use one item for the alignment marker\n    if (options.alignmentRound != null) {\n        // Hide alignment module, use alignment part\n        lines.push(`<path id=\"a\" d=\"\" visibility=\"hidden\" />`);\n        if (options.white) lines.push(`<path id=\"aw\" d=\"\" visibility=\"hidden\" />`);\n        lines.push(`<g id=\"ac\"><rect x=\"-2\" y=\"-2\" width=\"4\" height=\"4\" rx=\"${2.0 * options.alignmentRound}\" stroke=\"currentColor\" stroke-width=\"1\" fill=\"none\" /><rect x=\"-0.5\" y=\"-0.5\" width=\"1\" height=\"1\" rx=\"${0.5 * options.alignmentRound}\" /></g>`);\n    } else {\n        // Use normal module for alignment module, hide alignment part\n        lines.push(`<use id=\"a\" xlink:href=\"#b\" />`);\n        if (options.white) lines.push(`<use id=\"aw\" xlink:href=\"#w\" />`);\n        lines.push(`<path id=\"ac\" d=\"\" visibility=\"hidden\" />`);\n    }\n    lines.push(`</defs>`);\n    for(let y = 0; y < matrix.dimension; y++)for(let x = 0; x < matrix.dimension; x++){\n        const mod = matrix.identifyModule(x, y);\n        let bit = matrix.getModule(x, y);\n        // IMPORTANT: Inverting the output for SVGs will not be correct if a single finder pattern is used (it would need inverting)\n        if (matrix.invert) bit = !bit;\n        let type = bit ? \"b\" : \"w\";\n        // Draw finder/alignment as modules (define to nothing if drawing as whole parts)\n        if (mod == \"Fi\" || mod == \"FI\") type = bit ? \"f\" : \"fw\";\n        else if (mod == \"Al\" || mod == \"AL\") type = bit ? \"a\" : \"aw\";\n        if (bit || options.white) lines.push(`<use x=\"${x}\" y=\"${y}\" xlink:href=\"#${type}\" />`);\n    }\n    // Draw finder/alignment as whole parts (define to nothing if drawing as modules)\n    for(let y = 0; y < matrix.dimension; y++)for(let x = 0; x < matrix.dimension; x++){\n        const mod = matrix.identifyModule(x, y);\n        let type = null;\n        if (mod == \"FI\") type = \"fc\";\n        else if (mod == \"AL\") type = \"ac\";\n        if (type == null) continue;\n        lines.push(`<use x=\"${x}\" y=\"${y}\" xlink:href=\"#${type}\" />`);\n    }\n    lines.push(`</svg>`);\n    const svgString = lines.join(\"\\n\");\n    return svgString;\n}\nfunction $ea450d57d71c3369$var$renderSvgUri(matrix, options) {\n    return \"data:image/svg+xml,\" + encodeURIComponent($ea450d57d71c3369$var$renderSvg(matrix, options));\n}\nfunction $ea450d57d71c3369$var$renderBmp(matrix, options) {\n    options = Object.assign({\n        scale: 8,\n        alpha: false,\n        width: null,\n        height: null\n    }, options);\n    const size = matrix.dimension + 2 * matrix.quiet;\n    if (options.width === null) options.width = Math.floor(size * options.scale);\n    if (options.height === null) options.height = options.width;\n    const colorData = Array(options.width * options.height).fill(null);\n    for(let y = 0; y < options.height; y++){\n        const my = Math.floor(y * size / options.height) - matrix.quiet;\n        for(let x = 0; x < options.width; x++){\n            const mx = Math.floor(x * size / options.width) - matrix.quiet;\n            let bit = matrix.getModule(mx, my);\n            let color;\n            if (matrix.invert) color = bit ? [\n                255,\n                255,\n                255,\n                255\n            ] : [\n                0,\n                0,\n                0,\n                0\n            ];\n            else color = bit ? [\n                0,\n                0,\n                0,\n                255\n            ] : [\n                255,\n                255,\n                255,\n                0\n            ];\n            colorData[y * options.width + x] = color;\n        }\n    }\n    const bmpData = $ea450d57d71c3369$var$BitmapGenerate(colorData, options.width, options.height, options.alpha);\n    return bmpData;\n}\nfunction $ea450d57d71c3369$var$renderBmpUri(matrix, options) {\n    const bmpData = $ea450d57d71c3369$var$renderBmp(matrix, options);\n    const encoded = btoa(new Uint8Array(bmpData).reduce((data, v)=>data + String.fromCharCode(v), \"\"));\n    return \"data:image/bmp;base64,\" + encoded;\n}\nvar // Comment-out the following line to convert this into a non-module .js file (e.g. for use in a <script src> tag over the file: protocol)\n$ea450d57d71c3369$export$2e2bcd8739ae039 = $ea450d57d71c3369$var$QrCode;\n\n\nconst $d63a8266effe4d07$var$generateQR = function(url) {\n    // Generate QR\n    const matrix = (0, $ea450d57d71c3369$export$2e2bcd8739ae039).generate(url);\n    const uri = (0, $ea450d57d71c3369$export$2e2bcd8739ae039).render(\"svg-uri\", matrix);\n    (0, $9945e03bc0452317$export$2e2bcd8739ae039).render(uri);\n};\nconst $d63a8266effe4d07$var$goToHome = function() {\n    (0, $2d6f167c801d3721$export$2e2bcd8739ae039).render();\n};\nconst $d63a8266effe4d07$var$init = function() {\n    (0, $2d6f167c801d3721$export$2e2bcd8739ae039).addHandlerSubmit($d63a8266effe4d07$var$generateQR);\n    (0, $9945e03bc0452317$export$2e2bcd8739ae039).addHandlerIcon($d63a8266effe4d07$var$goToHome);\n};\nwindow.addEventListener(\"load\", ()=>(0, $2d6f167c801d3721$export$2e2bcd8739ae039).render());\n$d63a8266effe4d07$var$init();\n\n\n//# sourceMappingURL=index.f251b61e.js.map\n","\"use strict\";\n\nvar mapping = {};\nfunction register(pairs) {\n  var keys = Object.keys(pairs);\n  for (var i = 0; i < keys.length; i++) {\n    mapping[keys[i]] = pairs[keys[i]];\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping[id];\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return resolved;\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","require('./helpers/bundle-manifest').register(JSON.parse(\"{\\\"392in\\\":\\\"index.f251b61e.js\\\",\\\"jAwCd\\\":\\\"yeom-icon.c59e79dd.png\\\",\\\"jUwq8\\\":\\\"download.9ea3826b.svg\\\",\\\"frheu\\\":\\\"share.99e75b50.svg\\\"}\"));","/****************\\\n* Challenge #1   *\n* Querre         *\n* By: @yeomfa    *\n\\****************/\nimport formView from \"./views/formView.js\";\nimport qrView from \"./views/qrView.js\";\nimport QrCode from \"./thirdparties/qrcode.js\";\n\nconst generateQR = function(url) {\n  // Generate QR\n  const matrix = QrCode.generate(url);\n  const uri = QrCode.render('svg-uri', matrix);\n\n  qrView.render(uri);\n}\n\nconst goToHome = function() {\n  formView.render();\n}\n\nconst init = function() {\n  formView.addHandlerSubmit(generateQR);\n  qrView.addHandlerIcon(goToHome);\n}\nwindow.addEventListener('load', () => formView.render())\ninit();\n","import yeomIcon from '/public/yeom-icon.png';\n\nclass FormView {\n  #parentElement = document.querySelector('.root');\n\n  render() {\n    const markup = `\n      <section class=\"container-input section-form\">\n        <div class=\"title\">\n          <img src=${yeomIcon} alt=\"yeom icon\">\n          <span>Querre</span>\n        </div>\n\n        <form class=\"app form-url\">\n          <input class=\"input-url\" type=\"text\" name=\"url\" value=\"\" placeholder=\"Enter an url\"> \n          <button class=\"btn-submit\" type=\"submit\">QR code</button>\n        </form>\n      </section>\n    `;\n\n    this.#parentElement.innerHTML = markup;\n  }\n\n  addHandlerSubmit(handler) {\n    this.#parentElement.addEventListener('submit', e => {\n      e.preventDefault();\n\n      const inputUrl = document.querySelector('.input-url');\n      const url = inputUrl.value;\n\n      if (url.length <= 1) return;\n\n      handler(url);\n      inputUrl.value = '';\n    });\n  }\n}\n\nexport default new FormView();\n","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"jAwCd\")).toString();","import yeomIcon from '/public/yeom-icon.png';\nimport downloadIcon from '../icons/download.svg';\nimport shareIcon from '../icons/share.svg';\n\nclass QRView {\n  #parentElement = document.querySelector('.root');\n\n  render(uri) {\n    const markup = `\n      <section class=\"container-qr section-qr\">\n        <header class=\"header-container\">\n          <div class=\"querre-icon\">\n            <img src=${yeomIcon} alt=\"yeom icon\">\n            <span>Querre</span>\n          </div>\n        </header>\n\n        <div class=\"qr\">\n          <div class=\"shape\">\n            <img id=\"qrcode\" src=${uri}>\n          </div>\n        </div>\n\n        <div class=\"options\">\n          <button class=\"btn btn-download\">\n            Download\n            <img class=\"btn-icon\" src=${downloadIcon} alt=\"download icon\">\n          </button> \n          <button class=\"btn btn-share\">\n            Share\n            <img class=\"btn-icon\" src=${shareIcon} alt=\"download icon\">\n          </button> \n        </div>\n      </section>\n    `;\n\n    this.#parentElement.innerHTML = markup;\n  }\n\n  addHandlerIcon(handler) {\n    this.#parentElement.addEventListener('click', e => {\n      const icon = e.target.closest('.querre-icon');\n\n      if (!icon) return;\n\n      handler();\n    });\n  }\n\n  getQRElement() {\n    const qrEl = document.getElementById('qrcode');\n    return qrEl;\n  }\n}\n\nexport default new QRView();\n","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"jUwq8\")).toString();","module.exports = new __parcel__URL__(require('./helpers/bundle-manifest').resolve(\"frheu\")).toString();","// QR Code Generator\n// Dan Jackson, 2020\n\n\n// --- Bit Buffer Writing ---\n\nclass BitBuffer {\n    constructor(bitCapacity) {\n        this.bitCapacity = bitCapacity;\n        const byteLength = (this.bitCapacity + 7) >> 3;\n        this.buffer = new Uint8Array(byteLength);\n        this.bitOffset = 0;\n    }\n\n    append(value, bitCount) {\n        for (let i = 0; i < bitCount; i++) {\n            const writeByte = this.buffer[(this.bitOffset) >> 3];\n            const writeBit = 7 - (this.bitOffset & 0x07);\n            const writeMask = 1 << writeBit;\n            const readMask = 1 << (bitCount - 1 - i);\n            this.buffer[this.bitOffset >> 3] = (writeByte & ~writeMask) | ((value & readMask) ? writeMask : 0);\n            this.bitOffset++;\n        }\n    }\n\n    position() {\n        return this.bitOffset;\n    }\n\n    read(bitPosition) {\n        const value = (this.buffer[bitPosition >> 3] & (1 << (7 - (bitPosition & 7)))) ? 1 : 0;\n        return value;\n    }\n}\n\n\n// --- Segment Modes ---\n\n// Segment Mode 0b0001 - Numeric\n// Maximal groups of 3/2/1 digits encoded to 10/7/4-bit binary\nclass SegmentNumeric {\n    static MODE = 0x01;\n    static CHARSET = '0123456789';\n\n    static canEncode(text) {\n        return [...text].every(c => SegmentNumeric.CHARSET.includes(c));\n    }\n\n    static payloadSize(text) {\n        const charCount = text.length;\n        return 10 * Math.floor(charCount / 3) + (charCount % 3 * 4) - Math.floor(charCount % 3 / 2);\n    }\n\n    static countSize(version) {\n        return (version < 10) ? 10 : (version < 27) ? 12 : 14;\n    }\n\n    static totalSize(version, text) {\n        return Segment.MODE_BITS + SegmentNumeric.countSize(version) + SegmentNumeric.payloadSize(text);\n    }\n\n    static encode(bitBuffer, version, text) {\n        const data = [...text].map(c => c.charCodeAt(0) - 0x30);\n        bitBuffer.append(SegmentNumeric.MODE, Segment.MODE_BITS);\n        bitBuffer.append(data.length, SegmentNumeric.countSize(version));\n        for (let i = 0; i < data.length; ) {\n            const remain = (data.length - i) > 3 ? 3 : (data.length - i);\n            let value = data[i];\n            let bits = 4;\n            i++;\n            // Maximal groups of 3/2/1 digits encoded to 10/7/4-bit binary\n            if (i < data.length) { value = value * 10 + data[i]; bits += 3; i++; }\n            if (i < data.length) { value = value * 10 + data[i]; bits += 3; i++; }\n            bitBuffer.append(value, bits);\n        }\n    }\n}\n\n// Segment Mode 0b0010 - Alphanumeric\nclass SegmentAlphanumeric {\n    static MODE = 0x02;\n    static CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';\n\n    static canEncode(text) {\n        return [...text].every(c => SegmentAlphanumeric.CHARSET.includes(c));\n    }\n\n    static payloadSize(text) {\n        const charCount = text.length;\n        return 11 * Math.floor(charCount / 2) + 6 * (charCount % 2);\n    }\n\n    static countSize(version) {\n        return (version < 10) ? 9 : (version < 27) ? 11 : 13;\n    }\n\n    static totalSize(version, text) {\n        return Segment.MODE_BITS + SegmentAlphanumeric.countSize(version) + SegmentAlphanumeric.payloadSize(text);\n    }\n\n    static encode(bitBuffer, version, text) {\n        const data = [...text].map(c => SegmentAlphanumeric.CHARSET.indexOf(c));\n        bitBuffer.append(SegmentAlphanumeric.MODE, Segment.MODE_BITS);\n        bitBuffer.append(data.length, SegmentAlphanumeric.countSize(version));\n        for (let i = 0; i < data.length; ) {\n            let value = data[i];\n            let bits = 6;\n            i++;\n            // Pairs combined(a * 45 + b) encoded as 11-bit; odd remainder encoded as 6-bit.\n            if (i < data.length) { value = value * 45 + data[i]; bits += 5; i++; }\n            bitBuffer.append(value, bits);\n        }\n    }\n}\n\n// Segment Mode 0b0100 - 8-bit byte\nclass SegmentEightBit {\n    static MODE = 0x04;\n\n    static canEncode(text) {\n        return [...text].every(c => c.charCodeAt(0) >= 0x00 && c.charCodeAt(0) <= 0xff);\n    }\n\n    static payloadSize(text) {\n        const charCount = text.length;\n        return 8 * charCount;\n    }\n\n    static countSize(version) {\n        return (version < 10) ? 8 : (version < 27) ? 16 : 16; // 8-bit\n    }\n\n    static totalSize(version, text) {\n        return Segment.MODE_BITS + SegmentEightBit.countSize(version) + SegmentEightBit.payloadSize(text);\n    }\n\n    static encode(bitBuffer, version, text) {\n        const data = [...text].map(c => c.charCodeAt(0));\n        bitBuffer.append(SegmentEightBit.MODE, Segment.MODE_BITS);\n        bitBuffer.append(data.length, SegmentEightBit.countSize(version));\n        for (let i = 0; i < data.length; i++) {\n            bitBuffer.append(data[i], 8);\n        }\n    }\n}\n\n\nclass Segment {\n    // In descending order of coding efficiency\n    static MODES = {\n        numeric: SegmentNumeric,\n        alphanumeric: SegmentAlphanumeric, \n        eightBit: SegmentEightBit,\n    };\n    static MODE_BITS = 4;    // 4-bits to indicate mode\n    static MODE_INDICATOR_TERMINATOR = 0x0;  // 0b0000\n    // ECI Assignment Numbers\n    //static ECI_UTF8 = 26; // \"\\000026\" UTF8 - ISO/IEC 10646 UTF-8 encoding\n\n\n    constructor(text) {\n        this.text = text;\n        for (let mode of Object.values(Segment.MODES)) {\n            if (mode.canEncode(this.text)) {\n                this.mode = mode;\n                return;\n            }\n        }\n        throw 'Cannot encode text';\n    }\n\n}\n\n\n// --- Reed-Solomon Error-Correction Code ---\n\n// These error-correction functions are derived from https://www.nayuki.io/page/qr-code-generator-library Copyright (c) Project Nayuki. (MIT License)\nclass ReedSolomon {\n\n    // Product modulo GF(2^8/0x011D)\n    static Multiply(a, b) { // both arguments 8-bit\n        let value = 0;  // 8-bit\n        for (let i = 7; i >= 0; i--) {\n            value = ((value << 1) ^ ((value >> 7) * 0x011D)) & 0xff;\n            value ^= ((b >> i) & 1) * a;\n        }\n        return value;\n    }\n\n    // Reed-Solomon ECC generator polynomial for given degree\n    static Divisor(degree) {\n        const result = new Uint8Array(degree); // <= QrCode.ECC_CODEWORDS_MAX\n        result.fill(0);\n        result[degree - 1] = 1;\n        let root = 1;   // 8-bit\n        for (let i = 0; i < degree; i++) {\n            for (let j = 0; j < degree; j++) {\n                result[j] = ReedSolomon.Multiply(result[j], root);\n                if (j + 1 < degree) {\n                    result[j] ^= result[j + 1];\n                }\n            }\n            root = ReedSolomon.Multiply(root, 0x02) & 0xff; // 8-bit\n        }\n        return result;\n    }\n\n    // Reed-Solomon ECC\n    static Remainder(data, dataOffset, dataLen, generator, degree, result, resultOffset) {\n        result.fill(0, resultOffset, resultOffset + degree);\n        for (let i = 0; i < dataLen; i++) {\n            let factor = data[dataOffset + i] ^ result[resultOffset + 0];\n            // Move (degree-1) bytes from result[resultOffset+1] to result[resultOffset+0].\n            result.copyWithin(resultOffset, resultOffset + 1, resultOffset + 1 + degree - 1)\n            result[resultOffset + degree - 1] = 0;\n            for (let j = 0; j < degree; j++) {\n                result[resultOffset + j] ^= ReedSolomon.Multiply(generator[j], factor);\n            }\n        }\n    }\n\n}\n\n\n// --- 2D Matrix ---\n\nclass Matrix {\n    \n    static MODULE_LIGHT = 0;\n    static MODULE_DARK = 1;\n\n    static FINDER_SIZE = 7;\n    static TIMING_OFFSET = 6;\n    static VERSION_SIZE = 3;\n    static ALIGNMENT_RADIUS = 2;\n    static QUIET_NONE = 0;\n    static QUIET_STANDARD = 4;\n\n    static calculateDimension(version) {\n        return 17 + 4 * version; // V1=21x21; V40=177x177\n    }\n\n    static calculateMask(maskPattern, j, i) {\n        switch (maskPattern)\n        {\n            case 0: return ((i + j) & 1) == 0;                          // QRCODE_MASK_000\n            case 1: return (i & 1) == 0;                                // QRCODE_MASK_001\n            case 2: return j % 3 == 0;                                  // QRCODE_MASK_010\n            case 3: return (i + j) % 3 == 0;                            // QRCODE_MASK_011\n            case 4: return (((i >> 1) + ((j / 3)|0)) & 1) == 0;         // QRCODE_MASK_100\n            case 5: return ((i * j) & 1) + ((i * j) % 3) == 0;          // QRCODE_MASK_101\n            case 6: return ((((i * j) & 1) + ((i * j) % 3)) & 1) == 0;  // QRCODE_MASK_110\n            case 7: return ((((i * j) % 3) + ((i + j) & 1)) & 1) == 0;  // QRCODE_MASK_111\n            default: return false;\n        }\n    }\n\n    // Returns coordinates to be used in all combinations (unless overlapping finder pattern) as x/y pairs for alignment, <0: end\n    static alignmentCoordinates(version) {\n        const count = (version <= 1) ? 0 : Math.floor(version / 7) + 2;\n        const coords = Array(count);\n        const step = (version == 32) ? 26 : Math.floor((version * 4 + count * 2 + 1) / (count * 2 - 2)) * 2; // step to previous\n        let location = version * 4 + 10;    // lower alignment marker\n        for (let i = count - 1; i > 0; i--) {\n            coords[i] = location;\n            location -= step;\n        }\n        if (count > 0) coords[0] = 6;       // first alignment marker is at offset 6\n        return coords;\n    }\n\n    constructor(version) {\n        this.version = version;\n        this.dimension = Matrix.calculateDimension(this.version);\n        const capacity = this.dimension * this.dimension;\n        this.buffer = new Array(capacity);\n        this.identity = new Array(capacity);\n        this.quiet = Matrix.QUIET_STANDARD;\n        this.invert = false;\n        this.text = null;\n    }\n\n    setModule(x, y, value, identity) {\n        if (x < 0 || y < 0 || x >= this.dimension || y >= this.dimension) return;\n        const index = y * this.dimension + x;\n        this.buffer[index] = value;\n        if (typeof identity !== 'undefined') this.identity[index] = identity;\n    }\n\n    getModule(x, y) {\n        if (x < 0 || y < 0 || x >= this.dimension || y >= this.dimension) return null;\n        const index = y * this.dimension + x;\n        return this.buffer[index];\n    }\n\n    identifyModule(x, y) {\n        if (x < 0 || y < 0 || x >= this.dimension || y >= this.dimension) return undefined;\n        const index = y * this.dimension + x;\n        return this.identity[index];\n    }\n\n    // Draw finder and separator\n    drawFinder(ox, oy) {\n        for (let y = -Math.floor(Matrix.FINDER_SIZE / 2) - 1; y <= Math.floor(Matrix.FINDER_SIZE / 2) + 1; y++) {\n            for (let x = -Math.floor(Matrix.FINDER_SIZE / 2) - 1; x <= Math.floor(Matrix.FINDER_SIZE / 2) + 1; x++) {\n                let value = (Math.abs(x) > Math.abs(y) ? Math.abs(x) : Math.abs(y)) & 1 ? Matrix.MODULE_DARK : Matrix.MODULE_LIGHT;\n                if (x == 0 && y == 0) value = Matrix.MODULE_DARK;\n                const id = (x == 0 && y == 0) ? 'FI' : 'Fi';\n                this.setModule(ox + x, oy + y, value, id);\n            }\n        }    \n    }\n\n    drawTiming() {\n        const id = 'Ti';\n        for (let i = Matrix.FINDER_SIZE + 1; i < this.dimension - Matrix.FINDER_SIZE - 1; i++) {\n            let value = (~i & 1) ? Matrix.MODULE_DARK : Matrix.MODULE_LIGHT;\n            this.setModule(i, Matrix.TIMING_OFFSET, value, id);\n            this.setModule(Matrix.TIMING_OFFSET, i, value, id);\n        }\n    }\n\n    drawAlignment(ox, oy) {\n        for (let y = -Matrix.ALIGNMENT_RADIUS; y <= Matrix.ALIGNMENT_RADIUS; y++) {\n            for (let x = -Matrix.ALIGNMENT_RADIUS; x <= Matrix.ALIGNMENT_RADIUS; x++) {\n                let value = 1 - ((Math.abs(x) > Math.abs(y) ? Math.abs(x) : Math.abs(y)) & 1) ? Matrix.MODULE_DARK : Matrix.MODULE_LIGHT;\n                const id = (x == 0 && y == 0) ? 'AL' : 'Al';\n                this.setModule(ox + x, oy + y, value, id);\n            }\n        }\n    }\n\n    // Populate the matrix with function patterns: finder, separators, timing, alignment, temporary version & format info\n    populateFunctionPatterns() {\n        this.drawFinder(Math.floor(Matrix.FINDER_SIZE / 2), Math.floor(Matrix.FINDER_SIZE / 2));\n        this.drawFinder(this.dimension - 1 - Math.floor(Matrix.FINDER_SIZE / 2), Math.floor(Matrix.FINDER_SIZE / 2));\n        this.drawFinder(Math.floor(Matrix.FINDER_SIZE / 2), this.dimension - 1 - Math.floor(Matrix.FINDER_SIZE / 2));\n\n        this.drawTiming();\n\n        const alignmentCoords = Matrix.alignmentCoordinates(this.version);\n\n        for (let h of alignmentCoords) {\n            for (let v of alignmentCoords) {\n                if (h <= Matrix.FINDER_SIZE && v <= Matrix.FINDER_SIZE) continue;                        // Obscured by top-left finder\n                if (h >= this.dimension - 1 - Matrix.FINDER_SIZE && v <= Matrix.FINDER_SIZE) continue;   // Obscured by top-right finder\n                if (h <= Matrix.FINDER_SIZE && v >= this.dimension - 1 - Matrix.FINDER_SIZE) continue;   // Obscured by bottom-left finder\n                this.drawAlignment(h, v);\n            }\n        }\n        \n        // Draw placeholder format/version info (so that masking does not affect these parts)\n        this.drawFormatInfo(0);\n        this.drawVersionInfo(0);\n    }\n\n    // Set the data drawing cursor to the start position (lower-right corner)\n    cursorReset() {\n        this.cursorX = this.dimension - 1;\n        this.cursorY = this.dimension - 1;\n    }\n    \n    // Advance the data drawing cursor to next position\n    cursorAdvance() {\n        while (this.cursorX >= 0) {\n            // Right-hand side of 2-module column? (otherwise, left-hand side)\n            if ((this.cursorX & 1) ^ (this.cursorX > Matrix.TIMING_OFFSET ? 1 : 0)) {\n                this.cursorX--;\n            } else { // Left-hand side\n                this.cursorX++;\n                // Upwards? (otherwise, downwards)\n                if (((this.cursorX - (this.cursorX > Matrix.TIMING_OFFSET ? 1 : 0)) / 2) & 1) {\n                    if (this.cursorY <= 0) this.cursorX -= 2;\n                    else this.cursorY--;\n                } else {\n                    if (this.cursorY >= this.dimension - 1) this.cursorX -= 2;\n                    else this.cursorY++;\n                }\n            }\n            if (!this.identifyModule(this.cursorX, this.cursorY)) return true;\n        }\n        return false;\n    }\n\n    cursorWrite(buffer, sourceBit, countBits) {\n        let index = sourceBit;\n        for (let countWritten = 0; countWritten < countBits; countWritten++) {\n            let bit = buffer.read(index);\n            this.setModule(this.cursorX, this.cursorY, bit);\n            index++;\n            if (!this.cursorAdvance()) break;\n        }\n        return index - sourceBit;\n    }\n\n    // Draw 15-bit format information (2-bit error-correction level, 3-bit mask, 10-bit BCH error-correction; all masked)\n    drawFormatInfo(value) {\n        const id = 'Fo';\n        for (let i = 0; i < 15; i++) {\n            const v = (value >> i) & 1;\n\n            // 15-bits starting LSB clockwise from top-left finder avoiding timing strips\n            if (i < 6) this.setModule(Matrix.FINDER_SIZE + 1, i, v, id);\n            else if (i == 6) this.setModule(Matrix.FINDER_SIZE + 1, Matrix.FINDER_SIZE, v, id);\n            else if (i == 7) this.setModule(Matrix.FINDER_SIZE + 1, Matrix.FINDER_SIZE + 1, v, id);\n            else if (i == 8) this.setModule(Matrix.FINDER_SIZE, Matrix.FINDER_SIZE + 1, v, id);\n            else this.setModule(14 - i, Matrix.FINDER_SIZE + 1, v, id);\n\n            // lower 8-bits starting LSB right-to-left underneath top-right finder\n            if (i < 8) this.setModule(this.dimension - 1 - i, Matrix.FINDER_SIZE + 1, v, id);\n            // upper 7-bits starting LSB top-to-bottom right of bottom-left finder\n            else this.setModule(Matrix.FINDER_SIZE + 1, this.dimension - Matrix.FINDER_SIZE - 8 + i, v, id);\n        }\n        // dark module\n        this.setModule(Matrix.FINDER_SIZE + 1, this.dimension - 1 - Matrix.FINDER_SIZE, Matrix.MODULE_DARK, id);\n    }\n\n    // Draw 18-bit version information (6-bit version number, 12-bit error-correction (18,6) Golay code)\n    drawVersionInfo(value) {\n        const id = 'Ve';\n        // No version information on V1-V6\n        if (value === null || this.version < 7) return;\n        for (let i = 0; i < 18; i++) {\n            const v = (value >> i) & 1;\n            const col = Math.floor(i / Matrix.VERSION_SIZE);\n            const row = i % Matrix.VERSION_SIZE;\n            this.setModule(col, this.dimension - 1 - Matrix.FINDER_SIZE - Matrix.VERSION_SIZE + row, v, id);\n            this.setModule(this.dimension - 1 - Matrix.FINDER_SIZE - Matrix.VERSION_SIZE + row, col, v, id);\n        }\n    }\n\n    applyMaskPattern(maskPattern) {\n        for (let y = 0; y < this.dimension; y++) {\n            for (let x = 0; x < this.dimension; x++) {\n                const part = this.identifyModule(x, y);\n                if (!part) {\n                    const mask = Matrix.calculateMask(maskPattern, x, y);\n                    if (mask) {\n                        const module = this.getModule(x, y);\n                        const value = 1 ^ module;\n                        this.setModule(x, y, value);\n                    }\n                }\n            }\n        }\n    }\n\n    evaluatePenalty() {\n        // Note: Penalty calculated over entire code (although format information is not yet written)\n        const scoreN1 = 3;\n        //const scoreN2 = 3;\n        const scoreN3 = 40;\n        const scoreN4 = 10;\n        let totalPenalty = 0;\n\n        // Feature 1: Adjacent identical modules in row/column: (5 + i) count, penalty points: N1 + i\n        // Feature 3: 1:1:3:1:1 ratio patterns (either polarity) in row/column, penalty points: N3\n        for (let swapAxis = 0; swapAxis <= 1; swapAxis++) {\n            let runs = Array(5);\n            let runsCount = 0;\n            for (let y = 0; y < this.dimension; y++) {\n                let lastBit = -1;\n                let runLength = 0;\n                for (let x = 0; x < this.dimension; x++) {\n                    let bit = this.getModule(swapAxis ? y : x, swapAxis ? x : y);\n                    // Run extended\n                    if (bit == lastBit) runLength++;\n                    // End of run\n                    if (bit != lastBit || x >= this.dimension - 1) {\n                        // If not start condition\n                        if (lastBit >= 0) {\n                            // Feature 1\n                            if (runLength >= 5) { // or should this be strictly greater-than?\n                                totalPenalty += scoreN1 + (runLength - 5);\n                            }\n\n                            // Feature 3\n                            runsCount++;\n                            runs[runsCount % 5] = runLength;\n                            // Once we have a history of 5 lengths, check proportion\n                            if (runsCount >= 5) {\n                                // Proportion:             1 : 1 : 3 : 1 : 1\n                                // Modulo relative index: +3, +4,  0, +1, +2\n                                // Check for proportions\n                                let v = runs[(runsCount + 1) % 5];\n                                if (runs[runsCount % 5] == 3 * v && v == runs[(runsCount + 2) % 5] && v == runs[(runsCount + 3) % 5] && v == runs[(runsCount + 4) % 5]) {\n                                    totalPenalty += scoreN3;\n                                }\n                            }\n                        }\n                        runLength = 1;\n                        lastBit = bit;\n                    }\n                }\n            }\n        }\n\n        // Feature 2: Block of identical modules: m * n size, penalty points: N2 * (m-1) * (n-1)\n// TODO: Calculate feature 2 penalty. (Clear up ambiguity over \"block\" and counting the same \"block\" overlapped multiple times)\n        ; // scoreN2\n\n        // Feature 4: Dark module percentage: 50 +|- (5*k) to 50 +|- (5*(k+1)), penalty points: N4 * k\n        {\n            let darkCount = 0;\n            for (let y = 0; y < this.dimension; y++) {\n                for (let x = 0; x < this.dimension; x++) {\n                    let bit = this.getModule(x, y);\n                    if (bit == Matrix.MODULE_DARK) darkCount++;\n                }\n            }\n            // Deviation from 50%\n            let percentage = (100 * darkCount + (this.dimension * this.dimension / 2)) / (this.dimension * this.dimension);\n            let deviation = Math.abs(percentage - 50);\n            let rating = Math.floor(deviation / 5);\n            let penalty = scoreN4 * rating;\n            totalPenalty += penalty;\n        }\n\n        return totalPenalty;\n    }\n\n}\n\n\nclass QrCode {\n\n    static VERSION_MIN = 1;\n    static VERSION_MAX = 40;\n\n    // In ascending order of robustness\n    static ErrorCorrectionLevel = {\n        L: 0x01, // 0b01 Low (~7%)\n        M: 0x00, // 0b00 Medium (~15%)\n        Q: 0x03, // 0b11 Quartile (~25%)\n        H: 0x02, // 0b10 High (~30%)\n    };\n\n    static ECC_CODEWORDS_MAX = 30;\n    static PAD_CODEWORDS = 0xec11; // Pad codewords 0b11101100=0xec 0b00010001=0x11\n\n    // Calculate the (square) dimension for a version. V1=21x21; V40=177x177.\n    static dimension(version) {\n        return 17 + 4 * version;\n    }\n\n    // Calculate the total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.\n    static totalDataModules(version) {\n        return (((16 * version + 128) * version) + 64 - (version < 2 ? 0 : (25 * (Math.floor(version / 7) + 2) - 10) * (Math.floor(version / 7) + 2) - 55) - (version < 7 ? 0 : 36));\n    }\n\n    // Calculate the total number of data bits available in the codewords (cooked: after ecc and remainder)\n    static dataCapacity(version, errorCorrectionLevel) {\n        const capacityCodewords = Math.floor(QrCode.totalDataModules(version) / 8);\n        const eccTotalCodewords = QrCode.eccBlockCodewords(version, errorCorrectionLevel) * QrCode.eccBlockCount(version, errorCorrectionLevel);\n        const dataCapacityCodewords = capacityCodewords - eccTotalCodewords;\n        return dataCapacityCodewords * 8;\n    }\n\n    // Number of error correction blocks\n    static eccBlockCount(version, errorCorrectionLevel) {\n        const eccBlockCountLookup = [\n            [ 0, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5,  5,  8,  9,  9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49 ],    // 0b00 Medium\n            [ 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4,  4,  4,  4,  4,  6,  6,  6,  6,  7,  8,  8,  9,  9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25 ],    // 0b01 Low\n            [ 0, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81 ],    // 0b10 High\n            [ 0, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8,  8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68 ],    // 0b11 Quartile\n        ];\n        return eccBlockCountLookup[errorCorrectionLevel][version];\n    }\n\n    // Number of error correction codewords in each block\n    static eccBlockCodewords(version, errorCorrectionLevel) {\n        const eccBlockCodewordsLookup = [\n            [ 0, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28 ],  // 0b00 Medium\n            [ 0,  7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 ],  // 0b01 Low\n            [ 0, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 ],  // 0b10 High\n            [ 0, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30 ],  // 0b11 Quartile\n        ];\n        return eccBlockCodewordsLookup[errorCorrectionLevel][version];\n    }\n\n    // Calculate 18-bit version information (6-bit version number, 12-bit error-correction (18,6) Golay code)\n    static calculateVersionInfo(version) {\n        if (version < 7) return null;\n        // Calculate 12-bit error-correction (18,6) Golay code\n        let golay = version;\n        for (let i = 0; i < 12; i++) golay = (golay << 1) ^ ((golay >>> 11) * 0x1f25);\n        const value = (version << 12) | golay;\n        return value;\n    }\n\n    // Calculate 15-bit format information (2-bit error-correction level, 3-bit mask, 10-bit BCH error-correction; all masked)\n    static calculateFormatInfo(errorCorrectionLevel, maskPattern) {\n        // TODO: Reframe in terms of QRCODE_SIZE_ECL (2) and QRCODE_SIZE_MASK (3)\n\n        // LLMMM\n        const value = ((errorCorrectionLevel & 0x03) << 3) | (maskPattern & 0x07);\n\n        // Calculate 10-bit Bose-Chaudhuri-Hocquenghem (15,5) error-correction\n        let bch = value;\n        for (let i = 0; i < 10; i++) bch = (bch << 1) ^ ((bch >>> 9) * 0x0537);\n\n        // 0LLMMMEEEEEEEEEE\n        let format = (value << 10) | (bch & 0x03ff);\n        const formatMask = 0x5412;   // 0b0101010000010010\n        format ^= formatMask;\n\n        return format;\n    }\n\n\n    // Total number of data bits used (may later require 0-padding to a byte boundary and padding bytes added)\n    static measureSegments(segments, version) {\n        let total = 0;\n        for (let segment of segments) {\n            total += segment.mode.totalSize(version, segment.text);\n        }\n        return total;\n    }\n\n    static doSegmentsFit(segments, version, errorCorrectionLevel) {\n        const sizeBits = QrCode.measureSegments(segments, version);\n        const dataCapacity = QrCode.dataCapacity(version, errorCorrectionLevel);\n        return sizeBits <= dataCapacity;\n    }\n\n    static findMinimumVersion(segments, errorCorrectionLevel, minVersion = QrCode.VERSION_MIN, maxVersion = QrCode.VERSION_MAX) {\n        for (let version = minVersion; version <= maxVersion; version++) {\n            if (QrCode.doSegmentsFit(segments, version, errorCorrectionLevel)) {\n                return version;\n            }\n        }\n        throw 'Cannot fit data in any allowed versions';\n    }\n\n    static tryToImproveErrorCorrectionLevel(segments, version, currentErrorCorrectionLevel) {\n        const ranking = Object.values(QrCode.ErrorCorrectionLevel);\n        for (let i = 1; i < ranking.length; i++) {\n            if (currentErrorCorrectionLevel == ranking[i - 1]) {\n                if (QrCode.doSegmentsFit(segments, version, ranking[i])) {\n                    currentErrorCorrectionLevel = ranking[i];\n                }\n            }\n        }\n        return currentErrorCorrectionLevel;\n    }\n\n    // Write segments: header/count/payload\n    static writeData(scratchBuffer, version, segments) {   \n        // Add segments (mode, count and data)\n        for (let segment of segments) {\n            segment.mode.encode(scratchBuffer, version, segment.text);\n        }\n    }\n\n    // Finish segments: given the available space, write terminator, rounding bits, and padding codewords\n    static writePadding(scratchBuffer, version, errorCorrectionLevel) {   \n\n        // The total number of data bits available in the codewords (cooked: after ecc and remainder)\n        const dataCapacity = QrCode.dataCapacity(version, errorCorrectionLevel)\n\n        // Write only in capacity in any available space\n        let remaining;\n\n        // Add terminator 4-bit (0b0000)\n        remaining = Math.min(dataCapacity - scratchBuffer.position(), Segment.MODE_BITS);\n        scratchBuffer.append(Segment.MODE_INDICATOR_TERMINATOR, remaining);  // all zeros so won't be misaligned by partial write\n\n        // Remainder bits to round up to a whole byte\n        remaining = Math.min(dataCapacity - scratchBuffer.position(), (8 - (scratchBuffer.position() & 7)) & 7);\n        scratchBuffer.append(0x00, remaining);  // all zeros so won't be misaligned by partial write\n\n        // Remainder padding codewords \n        while ((remaining = Math.min(dataCapacity - scratchBuffer.position(), 16)) > 0) {\n            scratchBuffer.append(QrCode.PAD_CODEWORDS >> (16 - remaining), remaining); // align for partial write\n        }\n        \n        // Check position matches expectation\n        console.assert(scratchBuffer.position() === dataCapacity, 'Unexpectedly failed to correctly fill the data buffer');\n    }\n\n\n    // Calculate ECC data at the end of the codewords\n    // ...and fill the matrix\n    // TODO: Split this function into two (but depends on a lot of calculated state)\n    static calculateEccAndFillMatrix(scratchBuffer, version, errorCorrectionLevel, matrix) {\n        // Number of error correction blocks\n        const eccBlockCount = QrCode.eccBlockCount(version, errorCorrectionLevel);\n\n        // Number of error correction codewords in each block\n        const eccCodewords = QrCode.eccBlockCodewords(version, errorCorrectionLevel);\n\n        // The total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.\n        const totalCapacity = QrCode.totalDataModules(version);\n\n        // Codeword (byte) position in buffer for ECC data\n        const eccOffset = Math.floor((totalCapacity - (8 * eccCodewords * eccBlockCount)) / 8);\n\n        console.assert(8 * eccOffset === scratchBuffer.bitOffset, `Expected current bit position ${scratchBuffer.bitOffset} to match ECC offset *8 ${8 * eccOffset}`);\n\n        // Calculate Reed-Solomon divisor\n        const eccDivisor = ReedSolomon.Divisor(eccCodewords);\n\n        const dataCapacityBytes = eccOffset;\n        const dataLenShort = Math.floor(dataCapacityBytes / eccBlockCount);\n        const countShortBlocks = (eccBlockCount - (dataCapacityBytes - (dataLenShort * eccBlockCount)));\n        const dataLenLong = dataLenShort + (countShortBlocks >= eccBlockCount ? 0 : 1);\n        for (let block = 0; block < eccBlockCount; block++) {\n            // Calculate offset and length (earlier consecutive blocks may be short by 1 codeword)\n            let dataOffset;\n            if (block < countShortBlocks) {\n                dataOffset = block * dataLenShort;\n            } else {\n                dataOffset = block * dataLenShort + (block - countShortBlocks);\n            }\n            let dataLen = dataLenShort + (block < countShortBlocks ? 0 : 1);\n            // Calculate this block's ECC\n            let eccDest = eccOffset + (block * eccCodewords);\n            ReedSolomon.Remainder(scratchBuffer.buffer, dataOffset, dataLen, eccDivisor, eccCodewords, scratchBuffer.buffer, eccDest);\n        }\n\n\n        // Fill the matrix with data\n\n        // Write the codewords interleaved between blocks\n        matrix.cursorReset();\n        let totalWritten = 0;\n\n        // Write data codewords interleaved across ecc blocks -- some early blocks may be short\n        for (let i = 0; i < dataLenLong; i++) {\n            for (let block = 0; block < eccBlockCount; block++) {\n                // Calculate offset and length (earlier consecutive blocks may be short by 1 codeword)\n                // Skip codewords due to short block\n                if (i >= dataLenShort && block < countShortBlocks) continue;\n                const codeword = (block * dataLenShort) + (block > countShortBlocks ? block - countShortBlocks : 0) + i;\n                const sourceBit = codeword * 8;\n                const countBits = 8;\n                totalWritten += matrix.cursorWrite(scratchBuffer, sourceBit, countBits);\n            }\n        }\n\n        // Write ECC codewords interleaved across ecc blocks\n        for (let i = 0; i < eccCodewords; i++) {\n            for (let block = 0; block < eccBlockCount; block++) {\n                const sourceBit = 8 * eccOffset + (block * eccCodewords * 8) + (i * 8);\n                const countBits = 8;\n                totalWritten += matrix.cursorWrite(scratchBuffer, sourceBit, countBits);\n            }\n        }\n\n        // Add any remainder 0 bits (could be 0/3/4/7)\n        const bit = Matrix.MODULE_LIGHT;\n        while (totalWritten < totalCapacity) {\n            matrix.setModule(matrix.cursorX, matrix.cursorY, bit);\n            totalWritten++;\n            if (!matrix.cursorAdvance()) break;\n        }\n\n    }\n  \n\n    //\n    static findOptimalMaskPattern(matrix) {\n        let lowestPenalty = -1;\n        let bestMaskPattern = null;\n        for (let maskPattern = 0; maskPattern <= 7; maskPattern++) {\n            // XOR mask pattern\n            matrix.applyMaskPattern(maskPattern);\n\n            // Find penalty score for this mask pattern\n            const penalty = matrix.evaluatePenalty();\n\n            // XOR same mask removes it\n            matrix.applyMaskPattern(maskPattern);\n\n            // See if this is the best so far\n            if (lowestPenalty < 0 || penalty < lowestPenalty) {\n                lowestPenalty = penalty;\n                bestMaskPattern = maskPattern;\n            }\n        }\n        return bestMaskPattern;       \n    }\n\n\n    constructor() {\n    }\n\n    static generate(text, userOptions) {\n\n        // Generation options\n        const options = Object.assign({\n            errorCorrectionLevel: QrCode.ErrorCorrectionLevel.M,\n            minVersion: QrCode.VERSION_MIN,\n            maxVersion: QrCode.VERSION_MAX,\n            optimizeEcc: true,\n            maskPattern: null,\n            quiet: Matrix.QUIET_STANDARD,   // only information for the renderer\n            invert: false,                  // only a flag for the renderer\n        }, userOptions)\n\n        // Allow either a single text string or an array of text strings likely to encode as different modes\n        const textArray = Array.isArray(text) ? text : [text];\n\n        // Create a segment for the text, each with its own best-fit encoding mode\n        const segments = textArray.map(text => new Segment(text));\n\n        // Fit the payload to a version (dimension)\n        let errorCorrectionLevel = options.errorCorrectionLevel;\n        const version = QrCode.findMinimumVersion(segments, errorCorrectionLevel, options.minVersion, options.maxVersion);\n        \n        // Try to find a better error correction level for the given size\n        if (options.optimizeEcc) {\n            errorCorrectionLevel = QrCode.tryToImproveErrorCorrectionLevel(segments, version, errorCorrectionLevel);\n        }\n\n        // 'scratchBuffer' to contain the entire data bitstream for the QR Code\n        // (payload with headers, terminator, rounding bits, padding modules, ECC, remainder bits)\n        const totalCapacity = QrCode.totalDataModules(version); // The total number of data modules in a version (raw: data, ecc and remainder bits); does not include finder/alignment/version/timing.\n        const scratchBuffer = new BitBuffer(totalCapacity);\n\n        // Write segments: header/count/payload\n        QrCode.writeData(scratchBuffer, version, segments);\n\n        // Finish segments: given the available space, write terminator, rounding bits, and padding codewords\n        QrCode.writePadding(scratchBuffer, version, errorCorrectionLevel);\n\n        // Create an empty matrix\n        const matrix = new Matrix(version);\n        matrix.text = text;\n        matrix.quiet = options.quiet;\n        matrix.invert = options.invert;\n\n        // Populate the matrix with function patterns: finder, separators, timing, alignment, temporary version & format info\n        matrix.populateFunctionPatterns();\n\n        // Calculate ECC and fill matrix\n        QrCode.calculateEccAndFillMatrix(scratchBuffer, version, errorCorrectionLevel, matrix);\n\n        // Calculate the optimal mask pattern\n        let maskPattern = options.maskPattern;\n        if (maskPattern === null) {\n            maskPattern = QrCode.findOptimalMaskPattern(matrix);\n        }\n\n        // Apply the chosen mask pattern\n        matrix.applyMaskPattern(maskPattern);\n\n        // Populate the matrix with version information\n        const versionInfo = QrCode.calculateVersionInfo(version);\n        matrix.drawVersionInfo(versionInfo);\n\n        // Fill-in format information\n        const formatInfo = QrCode.calculateFormatInfo(errorCorrectionLevel, maskPattern);\n        matrix.drawFormatInfo(formatInfo);\n\n        return matrix;\n    }\n\n    static render(mode, matrix, renderOptions) {\n        const renderers = {\n            'debug': renderDebug,\n            'large': renderTextLarge,\n            'medium': renderTextMedium,\n            'compact': renderTextCompact,\n            'svg': renderSvg,\n            'svg-uri': renderSvgUri,\n            'bmp': renderBmp,\n            'bmp-uri': renderBmpUri,\n        };\n        if (!renderers[mode]) throw new Error('ERROR: Invalid render mode: ' + mode);\n        return renderers[mode](matrix, renderOptions);\n    }\n\n}\n\n// Generate a bitmap from an array of [R,G,B] or [R,G,B,A] pixels\nfunction BitmapGenerate(data, width, height, alpha = false) {\n    const bitsPerPixel = alpha ? 32 : 24;\n    const fileHeaderSize = 14;\n    const bmpHeaderSizeByVersion = {\n        BITMAPCOREHEADER: 12,\n        BITMAPINFOHEADER: 40,\n        BITMAPV2INFOHEADER: 52,\n        BITMAPV3INFOHEADER: 56,\n        BITMAPV4HEADER: 108,\n        BITMAPV5HEADER: 124,\n    };\n    const version = alpha ? 'BITMAPV4HEADER' : 'BITMAPCOREHEADER'; // V3 provides alpha on Chrome, but V4 required for Firefox\n    if (!bmpHeaderSizeByVersion.hasOwnProperty(version))\n        throw `Unknown BMP header version: ${version}`;\n    const bmpHeaderSize = bmpHeaderSizeByVersion[version];\n    const stride = 4 * Math.floor((width * Math.floor((bitsPerPixel + 7) / 8) + 3) / 4); // Byte width of each line\n    const biSizeImage = stride * Math.abs(height); // Total number of bytes that will be written\n    const bfOffBits = fileHeaderSize + bmpHeaderSize; // + paletteSize\n    const bfSize = bfOffBits + biSizeImage;\n    const buffer = new ArrayBuffer(bfSize);\n    const view = new DataView(buffer);\n    // Write 14-byte BITMAPFILEHEADER\n    view.setUint8(0, 'B'.charCodeAt(0));\n    view.setUint8(1, 'M'.charCodeAt(0)); // @0 WORD bfType\n    view.setUint32(2, bfSize, true); // @2 DWORD bfSize\n    view.setUint16(6, 0, true); // @6 WORD bfReserved1\n    view.setUint16(8, 0, true); // @8 WORD bfReserved2\n    view.setUint32(10, bfOffBits, true); // @10 DWORD bfOffBits\n    if (bmpHeaderSize == bmpHeaderSizeByVersion.BITMAPCOREHEADER) { // (14+12=26) BITMAPCOREHEADER\n        view.setUint32(14, bmpHeaderSize, true); // @14 DWORD biSize\n        view.setUint16(18, width, true); // @18 WORD biWidth\n        view.setInt16(20, height, true); // @20 WORD biHeight\n        view.setUint16(22, 1, true); // @26 WORD biPlanes\n        view.setUint16(24, bitsPerPixel, true); // @28 WORD biBitCount\n    }\n    else if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPINFOHEADER) { // (14+40=54) BITMAPINFOHEADER\n        view.setUint32(14, bmpHeaderSize, true); // @14 DWORD biSize\n        view.setUint32(18, width, true); // @18 DWORD biWidth\n        view.setInt32(22, height, true); // @22 DWORD biHeight\n        view.setUint16(26, 1, true); // @26 WORD biPlanes\n        view.setUint16(28, bitsPerPixel, true); // @28 WORD biBitCount\n        view.setUint32(30, alpha ? 3 : 0, true); // @30 DWORD biCompression (0=BI_RGB, 3=BI_BITFIELDS, 6=BI_ALPHABITFIELDS on Win-CE-5)\n        view.setUint32(34, biSizeImage, true); // @34 DWORD biSizeImage\n        view.setUint32(38, 2835, true); // @38 DWORD biXPelsPerMeter\n        view.setUint32(42, 2835, true); // @42 DWORD biYPelsPerMeter\n        view.setUint32(46, 0, true); // @46 DWORD biClrUsed\n        view.setUint32(50, 0, true); // @50 DWORD biClrImportant\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV2INFOHEADER) { // (14+52=66) BITMAPV2INFOHEADER (+RGB BI_BITFIELDS)\n        view.setUint32(54, alpha ? 0x00ff0000 : 0x00000000, true); // @54 DWORD bRedMask\n        view.setUint32(58, alpha ? 0x0000ff00 : 0x00000000, true); // @58 DWORD bGreenMask\n        view.setUint32(62, alpha ? 0x000000ff : 0x00000000, true); // @62 DWORD bBlueMask\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV3INFOHEADER) { // (14+56=70) BITMAPV3INFOHEADER (+A BI_BITFIELDS)\n        view.setUint32(66, alpha ? 0xff000000 : 0x00000000, true); // @66 DWORD bAlphaMask\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV4HEADER) { // (14+108=122) BITMAPV4HEADER (color space and gamma correction)\n        const colorSpace = \"Win \"; // \"BGRs\";       // @ 70 DWORD bCSType\n        view.setUint8(70, colorSpace.charCodeAt(0));\n        view.setUint8(71, colorSpace.charCodeAt(1));\n        view.setUint8(72, colorSpace.charCodeAt(2));\n        view.setUint8(73, colorSpace.charCodeAt(3));\n        // @74 sizeof(CIEXYZTRIPLE)=36 (can be left empty for \"Win \")\n        view.setUint32(110, 0, true); // @110 DWORD bGammaRed\n        view.setUint32(114, 0, true); // @114 DWORD bGammaGreen\n        view.setUint32(118, 0, true); // @118 DWORD bGammaBlue\n    }\n    if (bmpHeaderSize >= bmpHeaderSizeByVersion.BITMAPV5HEADER) { // (14+124=138) BITMAPV5HEADER (ICC color profile)\n        view.setUint32(122, 0x4, true); // @122 DWORD bIntent (0x1=LCS_GM_BUSINESS, 0x2=LCS_GM_GRAPHICS, 0x4=LCS_GM_IMAGES, 0x8=LCS_GM_ABS_COLORIMETRIC)\n        view.setUint32(126, 0, true); // @126 DWORD bProfileData\n        view.setUint32(130, 0, true); // @130 DWORD bProfileSize\n        view.setUint32(134, 0, true); // @134 DWORD bReserved\n    }\n    // If there was one, write the palette here (fileHeaderSize + bmpHeaderSize)\n    // Write pixels\n    for (let y = 0; y < height; y++) {\n        let offset = bfOffBits + (height - 1 - y) * stride;\n        for (let x = 0; x < width; x++) {\n            const value = data[y * width + x];\n            view.setUint8(offset + 0, value[2]); // B\n            view.setUint8(offset + 1, value[1]); // G\n            view.setUint8(offset + 2, value[0]); // R\n            if (alpha) {\n                view.setUint8(offset + 3, value[3]); // A\n                offset += 4;\n            }\n            else {\n                offset += 3;\n            }\n        }\n    }\n    return buffer;\n}\n\n\nfunction renderDebug(matrix, options) {\n    options = Object.assign({\n        segments: ['  ', ''],\n        sep: '\\n',\n    }, options);\n    const lines = [];\n    for (let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y++) {\n        const parts = [];\n        for (let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x++) {\n            let part = matrix.identifyModule(x, y);\n            const bit = matrix.getModule(x, y) ? !matrix.invert : matrix.invert;\n            const value = bit ? 1 : 0;\n            if (typeof part == 'undefined' || part === null) part = options.segments[value];\n            parts.push(part);\n        }\n        lines.push(parts.join(''));\n    }    \n    return lines.join(options.sep);\n}\n\nfunction renderTextLarge(matrix, options) {\n    options = Object.assign({\n        segments: ['  ', ''],\n        sep: '\\n',\n    }, options);\n    const lines = [];\n    for (let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y++) {\n        const parts = [];\n        for (let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x++) {\n            const bit = matrix.getModule(x, y) ? !matrix.invert : matrix.invert;\n            const value = bit ? 1 : 0;\n            // If an additional segment type is specified, use it to identify data modules differently\n            const chars = (options.segments.length >= 3 && bit && !matrix.identifyModule(x, y)) ? options.segments[2] : options.segments[value];\n            parts.push(chars);\n        }\n        lines.push(parts.join(''));\n    }    \n    return lines.join(options.sep);\n}\n\nfunction renderTextMedium(matrix, options) {\n    options = Object.assign({\n        segments: [' ', '', '', ''],\n        sep: '\\n',\n    }, options);\n    const lines = [];\n    for (let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y += 2) {\n        const parts = [];\n        for (let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x++) {\n            const upper = matrix.getModule(x, y) ? !matrix.invert : matrix.invert;\n            const lower = (y + 1 < matrix.dimension ? matrix.getModule(x, y + 1) : 0) ? !matrix.invert : matrix.invert;\n            const value = (upper ? 0x01 : 0) | (lower ? 0x02 : 0);\n            // '', '', '' // '\\u{0020}' space, '\\u{2580}' upper half block, '\\u{2584}' lower half block, '\\u{2588}' block\n            const c = options.segments[value];\n            parts.push(c);\n        }\n        lines.push(parts.join(''));\n    }    \n    return lines.join(options.sep);\n}\n\nfunction renderTextCompact(matrix, options) {\n    options = Object.assign({\n        segments: [' ', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],\n        sep: '\\n',\n    }, options);\n    const lines = [];\n    for (let y = -matrix.quiet; y < matrix.dimension + matrix.quiet; y += 2) {\n        const parts = [];\n        for (let x = -matrix.quiet; x < matrix.dimension + matrix.quiet; x += 2) {\n            let value = 0;\n            value |= (matrix.getModule(x, y) ? !matrix.invert : matrix.invert) ? 0x01 : 0x00;\n            value |= (((x + 1 < matrix.dimension) ? matrix.getModule(x + 1, y) : 0) ? !matrix.invert : matrix.invert) ? 0x02 : 0x00;\n            value |= (((y + 1 < matrix.dimension) ? matrix.getModule(x, y + 1) : 0) ? !matrix.invert : matrix.invert) ? 0x04 : 0x00;\n            value |= (((y + 1 < matrix.dimension) && (x + 1 < matrix.dimension) ? matrix.getModule(x + 1, y + 1) : 0) ? !matrix.invert : matrix.invert) ? 0x08 : 0x00;\n            let c = options.segments[value];\n            parts.push(c);\n        }\n        lines.push(parts.join(''));\n    }    \n    return lines.join(options.sep);\n}\n\nfunction escape(text) {\n    return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\\"/g, '&quot;').replace(/\\'/g, \"&apos;\");\n}\n\nfunction renderSvg(matrix, options) {\n    options = Object.assign({\n        moduleRound: null,\n        finderRound: null,\n        alignmentRound: null,\n        white: false,    // Output an element for every module, not just black/dark ones but white/light ones too.\n        moduleSize: 1,\n    }, options);\n    \n    const vbTopLeft = `${-matrix.quiet - options.moduleSize / 2}`;\n    const vbWidthHeight = `${2 * (matrix.quiet + options.moduleSize / 2) + matrix.dimension - 1}`;\n    \n    const lines = [];\n    lines.push(`<?xml version=\"1.0\"?>`);\n    // viewport-fill=\\\"white\\\" \n    lines.push(`<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"currentColor\" viewBox=\"${vbTopLeft} ${vbTopLeft} ${vbWidthHeight} ${vbWidthHeight}\" shape-rendering=\"crispEdges\">`);\n    lines.push(`<title>${escape(matrix.text)}</title>`);\n    //lines.push(`<desc>${escape(matrix.text)}</desc>`);\n    lines.push(`<defs>`);\n\n    // module data bit (dark)\n    lines.push(`<rect id=\"b\" x=\"${-options.moduleSize / 2}\" y=\"${-options.moduleSize / 2}\" width=\"${options.moduleSize}\" height=\"${options.moduleSize}\" rx=\"${0.5 * (options.moduleRound || 0) * options.moduleSize}\" />`);\n\n    // module data bit (light). \n    if (options.white) { // Light modules as a ref to a placeholder empty element\n        lines.push(`<path id=\"w\" d=\"\" visibility=\"hidden\" />`);\n    }\n\n    // Use one item for the finder marker\n    if (options.finderRound != null) {\n        // Hide finder module, use finder part\n        lines.push(`<path id=\"f\" d=\"\" visibility=\"hidden\" />`);\n        if (options.white) lines.push(`<path id=\"fw\" d=\"\" visibility=\"hidden\" />`);\n        lines.push(`<g id=\"fc\"><rect x=\"-3\" y=\"-3\" width=\"6\" height=\"6\" rx=\"${3.0 * options.finderRound}\" stroke=\"currentColor\" stroke-width=\"1\" fill=\"none\" /><rect x=\"-1.5\" y=\"-1.5\" width=\"3\" height=\"3\" rx=\"${1.5 * options.finderRound}\" /></g>`);\n        lines.push(`<g id=\"fc\"><rect x=\"-3\" y=\"-3\" width=\"6\" height=\"6\" rx=\"${3.0 * options.finderRound}\" stroke=\"currentColor\" stroke-width=\"1\" fill=\"none\" /><rect x=\"-1.5\" y=\"-1.5\" width=\"3\" height=\"3\" rx=\"${1.5 * options.finderRound}\" /></g>`);\n    } else {\n        // Use normal module for finder module, hide finder part\n        lines.push(`<use id=\"f\" xlink:href=\"#b\" />`);\n        if (options.white) lines.push(`<use id=\"fw\" xlink:href=\"#w\" />`);\n        lines.push(`<path id=\"fc\" d=\"\" visibility=\"hidden\" />`);\n    }\n\n    // Use one item for the alignment marker\n    if (options.alignmentRound != null) {\n        // Hide alignment module, use alignment part\n        lines.push(`<path id=\"a\" d=\"\" visibility=\"hidden\" />`);\n        if (options.white) lines.push(`<path id=\"aw\" d=\"\" visibility=\"hidden\" />`);\n        lines.push(`<g id=\"ac\"><rect x=\"-2\" y=\"-2\" width=\"4\" height=\"4\" rx=\"${2.0 * options.alignmentRound}\" stroke=\"currentColor\" stroke-width=\"1\" fill=\"none\" /><rect x=\"-0.5\" y=\"-0.5\" width=\"1\" height=\"1\" rx=\"${0.5 * options.alignmentRound}\" /></g>`);\n    } else {\n        // Use normal module for alignment module, hide alignment part\n        lines.push(`<use id=\"a\" xlink:href=\"#b\" />`);\n        if (options.white) lines.push(`<use id=\"aw\" xlink:href=\"#w\" />`);\n        lines.push(`<path id=\"ac\" d=\"\" visibility=\"hidden\" />`);\n    }\n\n    lines.push(`</defs>`);\n\n    for (let y = 0; y < matrix.dimension; y++) {\n        for (let x = 0; x < matrix.dimension; x++) {\n            const mod = matrix.identifyModule(x, y);\n            let bit = matrix.getModule(x, y);\n            // IMPORTANT: Inverting the output for SVGs will not be correct if a single finder pattern is used (it would need inverting)\n            if (matrix.invert) bit = !bit;\n            let type = bit ? 'b' : 'w';\n\n            // Draw finder/alignment as modules (define to nothing if drawing as whole parts)\n            if (mod == 'Fi' || mod == 'FI') { type = bit ? 'f' : 'fw'; }\n            else if (mod == 'Al' || mod == 'AL') { type = bit ? 'a' : 'aw'; }\n\n            if (bit || options.white) {\n                lines.push(`<use x=\"${x}\" y=\"${y}\" xlink:href=\"#${type}\" />`);\n            }\n        }\n    }\n\n    // Draw finder/alignment as whole parts (define to nothing if drawing as modules)\n    for (let y = 0; y < matrix.dimension; y++) {\n        for (let x = 0; x < matrix.dimension; x++) {\n            const mod = matrix.identifyModule(x, y);\n            let type = null;\n            if (mod == 'FI') type = 'fc';\n            else if (mod == 'AL') type = 'ac';\n            if (type == null) continue;\n            lines.push(`<use x=\"${x}\" y=\"${y}\" xlink:href=\"#${type}\" />`);\n        }\n    }\n\n    lines.push(`</svg>`);\n\n    const svgString = lines.join('\\n');\n    return svgString;\n}\n\nfunction renderSvgUri(matrix, options) {\n    return 'data:image/svg+xml,' + encodeURIComponent(renderSvg(matrix, options));\n}\n\nfunction renderBmp(matrix, options) {\n    options = Object.assign({\n        scale: 8,\n        alpha: false,\n        width: null,\n        height: null,\n    }, options);\n    const size = matrix.dimension + 2 * matrix.quiet;\n    if (options.width === null) options.width = Math.floor(size * options.scale);\n    if (options.height === null) options.height = options.width;\n\n    const colorData = Array(options.width * options.height).fill(null);\n    for (let y = 0; y < options.height; y++) {\n        const my = Math.floor(y * size / options.height) - matrix.quiet;\n        for (let x = 0; x < options.width; x++) {\n            const mx = Math.floor(x * size / options.width) - matrix.quiet;\n            let bit = matrix.getModule(mx, my);\n            let color;\n            if (matrix.invert) {\n                color = bit ? [255, 255, 255, 255] : [0, 0, 0, 0];\n            } else {\n                color = bit ? [0, 0, 0, 255] : [255, 255, 255, 0];\n            }\n            colorData[y * options.width + x] = color;\n        }\n    }\n\n    const bmpData = BitmapGenerate(colorData, options.width, options.height, options.alpha);\n    return bmpData;\n}\n\nfunction renderBmpUri(matrix, options) {\n    const bmpData = renderBmp(matrix, options);\n    const encoded = btoa(new Uint8Array(bmpData).reduce((data, v) => data + String.fromCharCode(v), ''))\n    return 'data:image/bmp;base64,' + encoded;\n}\n\n\n// Comment-out the following line to convert this into a non-module .js file (e.g. for use in a <script src> tag over the file: protocol)\nexport default QrCode\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$interopDefault","a","__esModule","default","$parcel$global","globalThis","self","window","global","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$18c11f3350a906ea$export$6503ec6e8aabbaf","$18c11f3350a906ea$export$f7ad0328861e2f03","$18c11f3350a906ea$var$mapping","pairs","keys","i","length","resolved","JSON","parse","$637432a930fda980$exports","URL","resolve","url","toString","$2d6f167c801d3721$var$FormView","parentElement","document","querySelector","render","markup","innerHTML","addHandlerSubmit","handler","addEventListener","preventDefault","inputUrl","value","$2d6f167c801d3721$export$2e2bcd8739ae039","$7af7f59580a84b33$exports","$bfcc6e0f6bfdf03d$exports","$9945e03bc0452317$var$QRView","uri","addHandlerIcon","icon","target","closest","getQRElement","qrEl","getElementById","$9945e03bc0452317$export$2e2bcd8739ae039","$ea450d57d71c3369$var$BitBuffer","constructor","bitCapacity","byteLength","buffer","Uint8Array","bitOffset","append","bitCount","writeByte","writeBit","writeMask","readMask","position","read","bitPosition","$ea450d57d71c3369$var$SegmentNumeric","MODE","CHARSET","canEncode","text","every","c","includes","payloadSize","charCount","Math","floor","countSize","version","totalSize","$ea450d57d71c3369$var$Segment","MODE_BITS","encode","bitBuffer","data","map","charCodeAt","bits","$ea450d57d71c3369$var$SegmentAlphanumeric","indexOf","$ea450d57d71c3369$var$SegmentEightBit","MODES","numeric","alphanumeric","eightBit","MODE_INDICATOR_TERMINATOR","mode","values","$ea450d57d71c3369$var$ReedSolomon","Multiply","b","Divisor","degree","result","fill","root","j","Remainder","dataOffset","dataLen","generator","resultOffset","factor","copyWithin","$ea450d57d71c3369$var$Matrix","MODULE_LIGHT","MODULE_DARK","FINDER_SIZE","TIMING_OFFSET","VERSION_SIZE","ALIGNMENT_RADIUS","QUIET_NONE","QUIET_STANDARD","calculateDimension","calculateMask","maskPattern","alignmentCoordinates","count","coords","Array","step","location","dimension","capacity","identity","quiet","invert","setModule","x","y","index","getModule","identifyModule","drawFinder","ox","oy","abs","drawTiming","drawAlignment","populateFunctionPatterns","alignmentCoords","h","drawFormatInfo","drawVersionInfo","cursorReset","cursorX","cursorY","cursorAdvance","cursorWrite","sourceBit","countBits","countWritten","bit","col","row","applyMaskPattern","part","mask","evaluatePenalty","totalPenalty","swapAxis","runs","runsCount","lastBit","runLength","scoreN1","darkCount","scoreN4","deviation","percentage","$ea450d57d71c3369$var$QrCode","VERSION_MIN","VERSION_MAX","ErrorCorrectionLevel","L","M","Q","H","ECC_CODEWORDS_MAX","PAD_CODEWORDS","totalDataModules","dataCapacity","errorCorrectionLevel","capacityCodewords","eccTotalCodewords","eccBlockCodewords","eccBlockCount","dataCapacityCodewords","eccBlockCountLookup","eccBlockCodewordsLookup","calculateVersionInfo","golay","calculateFormatInfo","bch","format","measureSegments","segments","total","segment","doSegmentsFit","sizeBits","findMinimumVersion","minVersion","maxVersion","tryToImproveErrorCorrectionLevel","currentErrorCorrectionLevel","ranking","writeData","scratchBuffer","writePadding","remaining","min","console","assert","calculateEccAndFillMatrix","matrix","eccCodewords","totalCapacity","eccOffset","eccDivisor","dataLenShort","dataCapacityBytes","countShortBlocks","dataLenLong","block","eccDest","totalWritten","codeword","findOptimalMaskPattern","lowestPenalty","bestMaskPattern","penalty","generate","userOptions","options","assign","optimizeEcc","textArray","isArray","versionInfo","formatInfo","renderOptions","renderers","$ea450d57d71c3369$var$renderDebug","$ea450d57d71c3369$var$renderTextLarge","$ea450d57d71c3369$var$renderTextMedium","$ea450d57d71c3369$var$renderTextCompact","$ea450d57d71c3369$var$renderSvg","$ea450d57d71c3369$var$renderSvgUri","$ea450d57d71c3369$var$renderBmp","$ea450d57d71c3369$var$renderBmpUri","sep","lines","parts","push","join","chars","upper","lower","moduleRound","finderRound","alignmentRound","white","moduleSize","vbTopLeft","vbWidthHeight","replace","mod","type","svgString","encodeURIComponent","scale","alpha","width","height","size","colorData","my","color","mx","bmpData","$ea450d57d71c3369$var$BitmapGenerate","bitsPerPixel","bmpHeaderSizeByVersion","BITMAPCOREHEADER","BITMAPINFOHEADER","BITMAPV2INFOHEADER","BITMAPV3INFOHEADER","BITMAPV4HEADER","BITMAPV5HEADER","hasOwnProperty","bmpHeaderSize","stride","biSizeImage","bfOffBits","fileHeaderSize","bfSize","ArrayBuffer","view","DataView","setUint8","setUint32","setUint16","setInt16","setInt32","colorSpace","offset","encoded","btoa","reduce","String","fromCharCode"],"version":3,"file":"index.f251b61e.js.map"}